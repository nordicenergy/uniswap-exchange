{"ast":null,"code":"// Base58 encoding/decoding\n// Originally written by Mike Hearn for BitcoinJ\n// Copyright (c) 2011 Google Inc\n// Ported to JavaScript by Stefan Thomas\n// Merged Buffer refactorings from base58-native by Stephen Pair\n// Copyright (c) 2013 BitPay Inc\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nvar ALPHABET_MAP = {};\n\nfor (var i = 0; i < ALPHABET.length; i++) {\n  ALPHABET_MAP[ALPHABET.charAt(i)] = i;\n}\n\nvar BASE = 58;\n\nfunction encode(buffer) {\n  if (buffer.length === 0) return '';\n  var i,\n      j,\n      digits = [0];\n\n  for (i = 0; i < buffer.length; i++) {\n    for (j = 0; j < digits.length; j++) {\n      digits[j] <<= 8;\n    }\n\n    digits[0] += buffer[i];\n    var carry = 0;\n\n    for (j = 0; j < digits.length; ++j) {\n      digits[j] += carry;\n      carry = digits[j] / BASE | 0;\n      digits[j] %= BASE;\n    }\n\n    while (carry) {\n      digits.push(carry % BASE);\n      carry = carry / BASE | 0;\n    }\n  } // deal with leading zeros\n\n\n  for (i = 0; buffer[i] === 0 && i < buffer.length - 1; i++) {\n    digits.push(0);\n  } // convert digits to a string\n\n\n  var stringOutput = \"\";\n\n  for (var i = digits.length - 1; i >= 0; i--) {\n    stringOutput = stringOutput + ALPHABET[digits[i]];\n  }\n\n  return stringOutput;\n}\n\nfunction decode(string) {\n  if (string.length === 0) return [];\n  var i,\n      j,\n      bytes = [0];\n\n  for (i = 0; i < string.length; i++) {\n    var c = string[i];\n    if (!(c in ALPHABET_MAP)) throw new Error('Non-base58 character');\n\n    for (j = 0; j < bytes.length; j++) {\n      bytes[j] *= BASE;\n    }\n\n    bytes[0] += ALPHABET_MAP[c];\n    var carry = 0;\n\n    for (j = 0; j < bytes.length; ++j) {\n      bytes[j] += carry;\n      carry = bytes[j] >> 8;\n      bytes[j] &= 0xff;\n    }\n\n    while (carry) {\n      bytes.push(carry & 0xff);\n      carry >>= 8;\n    }\n  } // deal with leading zeros\n\n\n  for (i = 0; string[i] === '1' && i < string.length - 1; i++) {\n    bytes.push(0);\n  }\n\n  return bytes.reverse();\n}\n\nmodule.exports = {\n  encode: encode,\n  decode: decode\n};","map":{"version":3,"sources":["/workspace/uniswap-exchange/node_modules/coinstring/node_modules/bs58/lib/bs58.js"],"names":["ALPHABET","ALPHABET_MAP","i","length","charAt","BASE","encode","buffer","j","digits","carry","push","stringOutput","decode","string","bytes","c","Error","reverse","module","exports"],"mappings":"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","sourcesContent":["// Base58 encoding/decoding\n// Originally written by Mike Hearn for BitcoinJ\n// Copyright (c) 2011 Google Inc\n// Ported to JavaScript by Stefan Thomas\n// Merged Buffer refactorings from base58-native by Stephen Pair\n// Copyright (c) 2013 BitPay Inc\n\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\nvar ALPHABET_MAP = {}\nfor(var i = 0; i < ALPHABET.length; i++) {\n  ALPHABET_MAP[ALPHABET.charAt(i)] = i\n}\nvar BASE = 58\n\nfunction encode(buffer) {\n  if (buffer.length === 0) return ''\n\n  var i, j, digits = [0]\n  for (i = 0; i < buffer.length; i++) {\n    for (j = 0; j < digits.length; j++) digits[j] <<= 8\n\n    digits[0] += buffer[i]\n\n    var carry = 0\n    for (j = 0; j < digits.length; ++j) {\n      digits[j] += carry\n\n      carry = (digits[j] / BASE) | 0\n      digits[j] %= BASE\n    }\n\n    while (carry) {\n      digits.push(carry % BASE)\n\n      carry = (carry / BASE) | 0\n    }\n  }\n\n  // deal with leading zeros\n  for (i = 0; buffer[i] === 0 && i < buffer.length - 1; i++) digits.push(0)\n\n  // convert digits to a string\n  var stringOutput = \"\"\n  for (var i = digits.length - 1; i >= 0; i--) {\n    stringOutput = stringOutput + ALPHABET[digits[i]]\n  }\n  return stringOutput\n}\n\nfunction decode(string) {\n  if (string.length === 0) return []\n\n  var i, j, bytes = [0]\n  for (i = 0; i < string.length; i++) {\n    var c = string[i]\n    if (!(c in ALPHABET_MAP)) throw new Error('Non-base58 character')\n\n    for (j = 0; j < bytes.length; j++) bytes[j] *= BASE\n    bytes[0] += ALPHABET_MAP[c]\n\n    var carry = 0\n    for (j = 0; j < bytes.length; ++j) {\n      bytes[j] += carry\n\n      carry = bytes[j] >> 8\n      bytes[j] &= 0xff\n    }\n\n    while (carry) {\n      bytes.push(carry & 0xff)\n\n      carry >>= 8\n    }\n  }\n\n  // deal with leading zeros\n  for (i = 0; string[i] === '1' && i < string.length - 1; i++) bytes.push(0)\n\n  return bytes.reverse()\n}\n\nmodule.exports = {\n  encode: encode,\n  decode: decode\n}\n"]},"metadata":{},"sourceType":"script"}