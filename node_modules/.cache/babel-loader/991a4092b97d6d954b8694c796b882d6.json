{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\n\nvar createHash = require('create-hash');\n\nvar _pbkdf2 = require('pbkdf2');\n\nvar pbkdf2 = _pbkdf2.pbkdf2Sync;\nvar pbkdf2Async = _pbkdf2.pbkdf2;\n\nvar randomBytes = require('randombytes'); // use unorm until String.prototype.normalize gets better browser support\n\n\nvar unorm = require('unorm');\n\nvar CHINESE_SIMPLIFIED_WORDLIST = require('./wordlists/chinese_simplified.json');\n\nvar CHINESE_TRADITIONAL_WORDLIST = require('./wordlists/chinese_traditional.json');\n\nvar ENGLISH_WORDLIST = require('./wordlists/english.json');\n\nvar FRENCH_WORDLIST = require('./wordlists/french.json');\n\nvar ITALIAN_WORDLIST = require('./wordlists/italian.json');\n\nvar JAPANESE_WORDLIST = require('./wordlists/japanese.json');\n\nvar KOREAN_WORDLIST = require('./wordlists/korean.json');\n\nvar SPANISH_WORDLIST = require('./wordlists/spanish.json');\n\nvar DEFAULT_WORDLIST = ENGLISH_WORDLIST;\nvar INVALID_MNEMONIC = 'Invalid mnemonic';\nvar INVALID_ENTROPY = 'Invalid entropy';\nvar INVALID_CHECKSUM = 'Invalid mnemonic checksum';\n\nfunction lpad(str, padString, length) {\n  while (str.length < length) {\n    str = padString + str;\n  }\n\n  return str;\n}\n\nfunction binaryToByte(bin) {\n  return parseInt(bin, 2);\n}\n\nfunction bytesToBinary(bytes) {\n  return bytes.map(function (x) {\n    return lpad(x.toString(2), '0', 8);\n  }).join('');\n}\n\nfunction deriveChecksumBits(entropyBuffer) {\n  var ENT = entropyBuffer.length * 8;\n  var CS = ENT / 32;\n  var hash = createHash('sha256').update(entropyBuffer).digest();\n  return bytesToBinary([].slice.call(hash)).slice(0, CS);\n}\n\nfunction salt(password) {\n  return 'mnemonic' + (password || '');\n}\n\nfunction mnemonicToSeed(mnemonic, password) {\n  var mnemonicBuffer = Buffer.from(unorm.nfkd(mnemonic), 'utf8');\n  var saltBuffer = Buffer.from(salt(unorm.nfkd(password)), 'utf8');\n  return pbkdf2(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');\n}\n\nfunction mnemonicToSeedHex(mnemonic, password) {\n  return mnemonicToSeed(mnemonic, password).toString('hex');\n}\n\nfunction mnemonicToSeedAsync(mnemonic, password) {\n  return new Promise(function (resolve, reject) {\n    try {\n      var mnemonicBuffer = Buffer.from(unorm.nfkd(mnemonic), 'utf8');\n      var saltBuffer = Buffer.from(salt(unorm.nfkd(password)), 'utf8');\n    } catch (error) {\n      return reject(error);\n    }\n\n    pbkdf2Async(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512', function (err, data) {\n      if (err) return reject(err);else return resolve(data);\n    });\n  });\n}\n\nfunction mnemonicToSeedHexAsync(mnemonic, password) {\n  return mnemonicToSeedAsync(mnemonic, password).then(function (buf) {\n    return buf.toString('hex');\n  });\n}\n\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n  wordlist = wordlist || DEFAULT_WORDLIST;\n  var words = unorm.nfkd(mnemonic).split(' ');\n  if (words.length % 3 !== 0) throw new Error(INVALID_MNEMONIC); // convert word indices to 11 bit binary strings\n\n  var bits = words.map(function (word) {\n    var index = wordlist.indexOf(word);\n    if (index === -1) throw new Error(INVALID_MNEMONIC);\n    return lpad(index.toString(2), '0', 11);\n  }).join(''); // split the binary string into ENT/CS\n\n  var dividerIndex = Math.floor(bits.length / 33) * 32;\n  var entropyBits = bits.slice(0, dividerIndex);\n  var checksumBits = bits.slice(dividerIndex); // calculate the checksum and compare\n\n  var entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);\n  if (entropyBytes.length < 16) throw new Error(INVALID_ENTROPY);\n  if (entropyBytes.length > 32) throw new Error(INVALID_ENTROPY);\n  if (entropyBytes.length % 4 !== 0) throw new Error(INVALID_ENTROPY);\n  var entropy = Buffer.from(entropyBytes);\n  var newChecksum = deriveChecksumBits(entropy);\n  if (newChecksum !== checksumBits) throw new Error(INVALID_CHECKSUM);\n  return entropy.toString('hex');\n}\n\nfunction entropyToMnemonic(entropy, wordlist) {\n  if (!Buffer.isBuffer(entropy)) entropy = Buffer.from(entropy, 'hex');\n  wordlist = wordlist || DEFAULT_WORDLIST; // 128 <= ENT <= 256\n\n  if (entropy.length < 16) throw new TypeError(INVALID_ENTROPY);\n  if (entropy.length > 32) throw new TypeError(INVALID_ENTROPY);\n  if (entropy.length % 4 !== 0) throw new TypeError(INVALID_ENTROPY);\n  var entropyBits = bytesToBinary([].slice.call(entropy));\n  var checksumBits = deriveChecksumBits(entropy);\n  var bits = entropyBits + checksumBits;\n  var chunks = bits.match(/(.{1,11})/g);\n  var words = chunks.map(function (binary) {\n    var index = binaryToByte(binary);\n    return wordlist[index];\n  });\n  return wordlist === JAPANESE_WORDLIST ? words.join(\"\\u3000\") : words.join(' ');\n}\n\nfunction generateMnemonic(strength, rng, wordlist) {\n  strength = strength || 128;\n  if (strength % 32 !== 0) throw new TypeError(INVALID_ENTROPY);\n  rng = rng || randomBytes;\n  return entropyToMnemonic(rng(strength / 8), wordlist);\n}\n\nfunction validateMnemonic(mnemonic, wordlist) {\n  try {\n    mnemonicToEntropy(mnemonic, wordlist);\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}\n\nmodule.exports = {\n  mnemonicToSeed: mnemonicToSeed,\n  mnemonicToSeedAsync: mnemonicToSeedAsync,\n  mnemonicToSeedHex: mnemonicToSeedHex,\n  mnemonicToSeedHexAsync: mnemonicToSeedHexAsync,\n  mnemonicToEntropy: mnemonicToEntropy,\n  entropyToMnemonic: entropyToMnemonic,\n  generateMnemonic: generateMnemonic,\n  validateMnemonic: validateMnemonic,\n  wordlists: {\n    EN: ENGLISH_WORDLIST,\n    JA: JAPANESE_WORDLIST,\n    chinese_simplified: CHINESE_SIMPLIFIED_WORDLIST,\n    chinese_traditional: CHINESE_TRADITIONAL_WORDLIST,\n    english: ENGLISH_WORDLIST,\n    french: FRENCH_WORDLIST,\n    italian: ITALIAN_WORDLIST,\n    japanese: JAPANESE_WORDLIST,\n    korean: KOREAN_WORDLIST,\n    spanish: SPANISH_WORDLIST\n  }\n};","map":{"version":3,"sources":["/workspace/uniswap-exchange/node_modules/bip39/index.js"],"names":["Buffer","require","createHash","_pbkdf2","pbkdf2","pbkdf2Sync","pbkdf2Async","randomBytes","unorm","CHINESE_SIMPLIFIED_WORDLIST","CHINESE_TRADITIONAL_WORDLIST","ENGLISH_WORDLIST","FRENCH_WORDLIST","ITALIAN_WORDLIST","JAPANESE_WORDLIST","KOREAN_WORDLIST","SPANISH_WORDLIST","DEFAULT_WORDLIST","INVALID_MNEMONIC","INVALID_ENTROPY","INVALID_CHECKSUM","lpad","str","padString","length","binaryToByte","bin","parseInt","bytesToBinary","bytes","map","x","toString","join","deriveChecksumBits","entropyBuffer","ENT","CS","hash","update","digest","slice","call","salt","password","mnemonicToSeed","mnemonic","mnemonicBuffer","from","nfkd","saltBuffer","mnemonicToSeedHex","mnemonicToSeedAsync","Promise","resolve","reject","error","err","data","mnemonicToSeedHexAsync","then","buf","mnemonicToEntropy","wordlist","words","split","Error","bits","word","index","indexOf","dividerIndex","Math","floor","entropyBits","checksumBits","entropyBytes","match","entropy","newChecksum","entropyToMnemonic","isBuffer","TypeError","chunks","binary","generateMnemonic","strength","rng","validateMnemonic","e","module","exports","wordlists","EN","JA","chinese_simplified","chinese_traditional","english","french","italian","japanese","korean","spanish"],"mappings":"AAAA,IAAIA,MAAM,GAAGC,OAAO,CAAC,aAAD,CAAP,CAAuBD,MAApC;;AACA,IAAIE,UAAU,GAAGD,OAAO,CAAC,aAAD,CAAxB;;AACA,IAAIE,OAAO,GAAGF,OAAO,CAAC,QAAD,CAArB;;AACA,IAAIG,MAAM,GAAGD,OAAO,CAACE,UAArB;AACA,IAAIC,WAAW,GAAGH,OAAO,CAACC,MAA1B;;AACA,IAAIG,WAAW,GAAGN,OAAO,CAAC,aAAD,CAAzB,C,CAEA;;;AACA,IAAIO,KAAK,GAAGP,OAAO,CAAC,OAAD,CAAnB;;AAEA,IAAIQ,2BAA2B,GAAGR,OAAO,CAAC,qCAAD,CAAzC;;AACA,IAAIS,4BAA4B,GAAGT,OAAO,CAAC,sCAAD,CAA1C;;AACA,IAAIU,gBAAgB,GAAGV,OAAO,CAAC,0BAAD,CAA9B;;AACA,IAAIW,eAAe,GAAGX,OAAO,CAAC,yBAAD,CAA7B;;AACA,IAAIY,gBAAgB,GAAGZ,OAAO,CAAC,0BAAD,CAA9B;;AACA,IAAIa,iBAAiB,GAAGb,OAAO,CAAC,2BAAD,CAA/B;;AACA,IAAIc,eAAe,GAAGd,OAAO,CAAC,yBAAD,CAA7B;;AACA,IAAIe,gBAAgB,GAAGf,OAAO,CAAC,0BAAD,CAA9B;;AACA,IAAIgB,gBAAgB,GAAGN,gBAAvB;AAEA,IAAIO,gBAAgB,GAAG,kBAAvB;AACA,IAAIC,eAAe,GAAG,iBAAtB;AACA,IAAIC,gBAAgB,GAAG,2BAAvB;;AAEA,SAASC,IAAT,CAAeC,GAAf,EAAoBC,SAApB,EAA+BC,MAA/B,EAAuC;AACrC,SAAOF,GAAG,CAACE,MAAJ,GAAaA,MAApB;AAA4BF,IAAAA,GAAG,GAAGC,SAAS,GAAGD,GAAlB;AAA5B;;AACA,SAAOA,GAAP;AACD;;AAED,SAASG,YAAT,CAAuBC,GAAvB,EAA4B;AAC1B,SAAOC,QAAQ,CAACD,GAAD,EAAM,CAAN,CAAf;AACD;;AAED,SAASE,aAAT,CAAwBC,KAAxB,EAA+B;AAC7B,SAAOA,KAAK,CAACC,GAAN,CAAU,UAAUC,CAAV,EAAa;AAC5B,WAAOV,IAAI,CAACU,CAAC,CAACC,QAAF,CAAW,CAAX,CAAD,EAAgB,GAAhB,EAAqB,CAArB,CAAX;AACD,GAFM,EAEJC,IAFI,CAEC,EAFD,CAAP;AAGD;;AAED,SAASC,kBAAT,CAA6BC,aAA7B,EAA4C;AAC1C,MAAIC,GAAG,GAAGD,aAAa,CAACX,MAAd,GAAuB,CAAjC;AACA,MAAIa,EAAE,GAAGD,GAAG,GAAG,EAAf;AACA,MAAIE,IAAI,GAAGpC,UAAU,CAAC,QAAD,CAAV,CAAqBqC,MAArB,CAA4BJ,aAA5B,EAA2CK,MAA3C,EAAX;AAEA,SAAOZ,aAAa,CAAC,GAAGa,KAAH,CAASC,IAAT,CAAcJ,IAAd,CAAD,CAAb,CAAmCG,KAAnC,CAAyC,CAAzC,EAA4CJ,EAA5C,CAAP;AACD;;AAED,SAASM,IAAT,CAAeC,QAAf,EAAyB;AACvB,SAAO,cAAcA,QAAQ,IAAI,EAA1B,CAAP;AACD;;AAED,SAASC,cAAT,CAAyBC,QAAzB,EAAmCF,QAAnC,EAA6C;AAC3C,MAAIG,cAAc,GAAG/C,MAAM,CAACgD,IAAP,CAAYxC,KAAK,CAACyC,IAAN,CAAWH,QAAX,CAAZ,EAAkC,MAAlC,CAArB;AACA,MAAII,UAAU,GAAGlD,MAAM,CAACgD,IAAP,CAAYL,IAAI,CAACnC,KAAK,CAACyC,IAAN,CAAWL,QAAX,CAAD,CAAhB,EAAwC,MAAxC,CAAjB;AAEA,SAAOxC,MAAM,CAAC2C,cAAD,EAAiBG,UAAjB,EAA6B,IAA7B,EAAmC,EAAnC,EAAuC,QAAvC,CAAb;AACD;;AAED,SAASC,iBAAT,CAA4BL,QAA5B,EAAsCF,QAAtC,EAAgD;AAC9C,SAAOC,cAAc,CAACC,QAAD,EAAWF,QAAX,CAAd,CAAmCZ,QAAnC,CAA4C,KAA5C,CAAP;AACD;;AAED,SAASoB,mBAAT,CAA8BN,QAA9B,EAAwCF,QAAxC,EAAkD;AAChD,SAAO,IAAIS,OAAJ,CAAY,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AAC5C,QAAI;AACF,UAAIR,cAAc,GAAG/C,MAAM,CAACgD,IAAP,CAAYxC,KAAK,CAACyC,IAAN,CAAWH,QAAX,CAAZ,EAAkC,MAAlC,CAArB;AACA,UAAII,UAAU,GAAGlD,MAAM,CAACgD,IAAP,CAAYL,IAAI,CAACnC,KAAK,CAACyC,IAAN,CAAWL,QAAX,CAAD,CAAhB,EAAwC,MAAxC,CAAjB;AACD,KAHD,CAGE,OAAOY,KAAP,EAAc;AACd,aAAOD,MAAM,CAACC,KAAD,CAAb;AACD;;AAEDlD,IAAAA,WAAW,CAACyC,cAAD,EAAiBG,UAAjB,EAA6B,IAA7B,EAAmC,EAAnC,EAAuC,QAAvC,EAAiD,UAAUO,GAAV,EAAeC,IAAf,EAAqB;AAC/E,UAAID,GAAJ,EAAS,OAAOF,MAAM,CAACE,GAAD,CAAb,CAAT,KACK,OAAOH,OAAO,CAACI,IAAD,CAAd;AACN,KAHU,CAAX;AAID,GAZM,CAAP;AAaD;;AAED,SAASC,sBAAT,CAAiCb,QAAjC,EAA2CF,QAA3C,EAAqD;AACnD,SAAOQ,mBAAmB,CAACN,QAAD,EAAWF,QAAX,CAAnB,CACJgB,IADI,CACC,UAAUC,GAAV,EAAe;AAAE,WAAOA,GAAG,CAAC7B,QAAJ,CAAa,KAAb,CAAP;AAA4B,GAD9C,CAAP;AAED;;AAED,SAAS8B,iBAAT,CAA4BhB,QAA5B,EAAsCiB,QAAtC,EAAgD;AAC9CA,EAAAA,QAAQ,GAAGA,QAAQ,IAAI9C,gBAAvB;AAEA,MAAI+C,KAAK,GAAGxD,KAAK,CAACyC,IAAN,CAAWH,QAAX,EAAqBmB,KAArB,CAA2B,GAA3B,CAAZ;AACA,MAAID,KAAK,CAACxC,MAAN,GAAe,CAAf,KAAqB,CAAzB,EAA4B,MAAM,IAAI0C,KAAJ,CAAUhD,gBAAV,CAAN,CAJkB,CAM9C;;AACA,MAAIiD,IAAI,GAAGH,KAAK,CAAClC,GAAN,CAAU,UAAUsC,IAAV,EAAgB;AACnC,QAAIC,KAAK,GAAGN,QAAQ,CAACO,OAAT,CAAiBF,IAAjB,CAAZ;AACA,QAAIC,KAAK,KAAK,CAAC,CAAf,EAAkB,MAAM,IAAIH,KAAJ,CAAUhD,gBAAV,CAAN;AAElB,WAAOG,IAAI,CAACgD,KAAK,CAACrC,QAAN,CAAe,CAAf,CAAD,EAAoB,GAApB,EAAyB,EAAzB,CAAX;AACD,GALU,EAKRC,IALQ,CAKH,EALG,CAAX,CAP8C,CAc9C;;AACA,MAAIsC,YAAY,GAAGC,IAAI,CAACC,KAAL,CAAWN,IAAI,CAAC3C,MAAL,GAAc,EAAzB,IAA+B,EAAlD;AACA,MAAIkD,WAAW,GAAGP,IAAI,CAAC1B,KAAL,CAAW,CAAX,EAAc8B,YAAd,CAAlB;AACA,MAAII,YAAY,GAAGR,IAAI,CAAC1B,KAAL,CAAW8B,YAAX,CAAnB,CAjB8C,CAmB9C;;AACA,MAAIK,YAAY,GAAGF,WAAW,CAACG,KAAZ,CAAkB,WAAlB,EAA+B/C,GAA/B,CAAmCL,YAAnC,CAAnB;AACA,MAAImD,YAAY,CAACpD,MAAb,GAAsB,EAA1B,EAA8B,MAAM,IAAI0C,KAAJ,CAAU/C,eAAV,CAAN;AAC9B,MAAIyD,YAAY,CAACpD,MAAb,GAAsB,EAA1B,EAA8B,MAAM,IAAI0C,KAAJ,CAAU/C,eAAV,CAAN;AAC9B,MAAIyD,YAAY,CAACpD,MAAb,GAAsB,CAAtB,KAA4B,CAAhC,EAAmC,MAAM,IAAI0C,KAAJ,CAAU/C,eAAV,CAAN;AAEnC,MAAI2D,OAAO,GAAG9E,MAAM,CAACgD,IAAP,CAAY4B,YAAZ,CAAd;AACA,MAAIG,WAAW,GAAG7C,kBAAkB,CAAC4C,OAAD,CAApC;AACA,MAAIC,WAAW,KAAKJ,YAApB,EAAkC,MAAM,IAAIT,KAAJ,CAAU9C,gBAAV,CAAN;AAElC,SAAO0D,OAAO,CAAC9C,QAAR,CAAiB,KAAjB,CAAP;AACD;;AAED,SAASgD,iBAAT,CAA4BF,OAA5B,EAAqCf,QAArC,EAA+C;AAC7C,MAAI,CAAC/D,MAAM,CAACiF,QAAP,CAAgBH,OAAhB,CAAL,EAA+BA,OAAO,GAAG9E,MAAM,CAACgD,IAAP,CAAY8B,OAAZ,EAAqB,KAArB,CAAV;AAC/Bf,EAAAA,QAAQ,GAAGA,QAAQ,IAAI9C,gBAAvB,CAF6C,CAI7C;;AACA,MAAI6D,OAAO,CAACtD,MAAR,GAAiB,EAArB,EAAyB,MAAM,IAAI0D,SAAJ,CAAc/D,eAAd,CAAN;AACzB,MAAI2D,OAAO,CAACtD,MAAR,GAAiB,EAArB,EAAyB,MAAM,IAAI0D,SAAJ,CAAc/D,eAAd,CAAN;AACzB,MAAI2D,OAAO,CAACtD,MAAR,GAAiB,CAAjB,KAAuB,CAA3B,EAA8B,MAAM,IAAI0D,SAAJ,CAAc/D,eAAd,CAAN;AAE9B,MAAIuD,WAAW,GAAG9C,aAAa,CAAC,GAAGa,KAAH,CAASC,IAAT,CAAcoC,OAAd,CAAD,CAA/B;AACA,MAAIH,YAAY,GAAGzC,kBAAkB,CAAC4C,OAAD,CAArC;AAEA,MAAIX,IAAI,GAAGO,WAAW,GAAGC,YAAzB;AACA,MAAIQ,MAAM,GAAGhB,IAAI,CAACU,KAAL,CAAW,YAAX,CAAb;AACA,MAAIb,KAAK,GAAGmB,MAAM,CAACrD,GAAP,CAAW,UAAUsD,MAAV,EAAkB;AACvC,QAAIf,KAAK,GAAG5C,YAAY,CAAC2D,MAAD,CAAxB;AACA,WAAOrB,QAAQ,CAACM,KAAD,CAAf;AACD,GAHW,CAAZ;AAKA,SAAON,QAAQ,KAAKjD,iBAAb,GAAiCkD,KAAK,CAAC/B,IAAN,CAAW,QAAX,CAAjC,GAAwD+B,KAAK,CAAC/B,IAAN,CAAW,GAAX,CAA/D;AACD;;AAED,SAASoD,gBAAT,CAA2BC,QAA3B,EAAqCC,GAArC,EAA0CxB,QAA1C,EAAoD;AAClDuB,EAAAA,QAAQ,GAAGA,QAAQ,IAAI,GAAvB;AACA,MAAIA,QAAQ,GAAG,EAAX,KAAkB,CAAtB,EAAyB,MAAM,IAAIJ,SAAJ,CAAc/D,eAAd,CAAN;AACzBoE,EAAAA,GAAG,GAAGA,GAAG,IAAIhF,WAAb;AAEA,SAAOyE,iBAAiB,CAACO,GAAG,CAACD,QAAQ,GAAG,CAAZ,CAAJ,EAAoBvB,QAApB,CAAxB;AACD;;AAED,SAASyB,gBAAT,CAA2B1C,QAA3B,EAAqCiB,QAArC,EAA+C;AAC7C,MAAI;AACFD,IAAAA,iBAAiB,CAAChB,QAAD,EAAWiB,QAAX,CAAjB;AACD,GAFD,CAEE,OAAO0B,CAAP,EAAU;AACV,WAAO,KAAP;AACD;;AAED,SAAO,IAAP;AACD;;AAEDC,MAAM,CAACC,OAAP,GAAiB;AACf9C,EAAAA,cAAc,EAAEA,cADD;AAEfO,EAAAA,mBAAmB,EAAEA,mBAFN;AAGfD,EAAAA,iBAAiB,EAAEA,iBAHJ;AAIfQ,EAAAA,sBAAsB,EAAEA,sBAJT;AAKfG,EAAAA,iBAAiB,EAAEA,iBALJ;AAMfkB,EAAAA,iBAAiB,EAAEA,iBANJ;AAOfK,EAAAA,gBAAgB,EAAEA,gBAPH;AAQfG,EAAAA,gBAAgB,EAAEA,gBARH;AASfI,EAAAA,SAAS,EAAE;AACTC,IAAAA,EAAE,EAAElF,gBADK;AAETmF,IAAAA,EAAE,EAAEhF,iBAFK;AAITiF,IAAAA,kBAAkB,EAAEtF,2BAJX;AAKTuF,IAAAA,mBAAmB,EAAEtF,4BALZ;AAMTuF,IAAAA,OAAO,EAAEtF,gBANA;AAOTuF,IAAAA,MAAM,EAAEtF,eAPC;AAQTuF,IAAAA,OAAO,EAAEtF,gBARA;AASTuF,IAAAA,QAAQ,EAAEtF,iBATD;AAUTuF,IAAAA,MAAM,EAAEtF,eAVC;AAWTuF,IAAAA,OAAO,EAAEtF;AAXA;AATI,CAAjB","sourcesContent":["var Buffer = require('safe-buffer').Buffer\nvar createHash = require('create-hash')\nvar _pbkdf2 = require('pbkdf2')\nvar pbkdf2 = _pbkdf2.pbkdf2Sync\nvar pbkdf2Async = _pbkdf2.pbkdf2\nvar randomBytes = require('randombytes')\n\n// use unorm until String.prototype.normalize gets better browser support\nvar unorm = require('unorm')\n\nvar CHINESE_SIMPLIFIED_WORDLIST = require('./wordlists/chinese_simplified.json')\nvar CHINESE_TRADITIONAL_WORDLIST = require('./wordlists/chinese_traditional.json')\nvar ENGLISH_WORDLIST = require('./wordlists/english.json')\nvar FRENCH_WORDLIST = require('./wordlists/french.json')\nvar ITALIAN_WORDLIST = require('./wordlists/italian.json')\nvar JAPANESE_WORDLIST = require('./wordlists/japanese.json')\nvar KOREAN_WORDLIST = require('./wordlists/korean.json')\nvar SPANISH_WORDLIST = require('./wordlists/spanish.json')\nvar DEFAULT_WORDLIST = ENGLISH_WORDLIST\n\nvar INVALID_MNEMONIC = 'Invalid mnemonic'\nvar INVALID_ENTROPY = 'Invalid entropy'\nvar INVALID_CHECKSUM = 'Invalid mnemonic checksum'\n\nfunction lpad (str, padString, length) {\n  while (str.length < length) str = padString + str\n  return str\n}\n\nfunction binaryToByte (bin) {\n  return parseInt(bin, 2)\n}\n\nfunction bytesToBinary (bytes) {\n  return bytes.map(function (x) {\n    return lpad(x.toString(2), '0', 8)\n  }).join('')\n}\n\nfunction deriveChecksumBits (entropyBuffer) {\n  var ENT = entropyBuffer.length * 8\n  var CS = ENT / 32\n  var hash = createHash('sha256').update(entropyBuffer).digest()\n\n  return bytesToBinary([].slice.call(hash)).slice(0, CS)\n}\n\nfunction salt (password) {\n  return 'mnemonic' + (password || '')\n}\n\nfunction mnemonicToSeed (mnemonic, password) {\n  var mnemonicBuffer = Buffer.from(unorm.nfkd(mnemonic), 'utf8')\n  var saltBuffer = Buffer.from(salt(unorm.nfkd(password)), 'utf8')\n\n  return pbkdf2(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512')\n}\n\nfunction mnemonicToSeedHex (mnemonic, password) {\n  return mnemonicToSeed(mnemonic, password).toString('hex')\n}\n\nfunction mnemonicToSeedAsync (mnemonic, password) {\n  return new Promise(function (resolve, reject) {\n    try {\n      var mnemonicBuffer = Buffer.from(unorm.nfkd(mnemonic), 'utf8')\n      var saltBuffer = Buffer.from(salt(unorm.nfkd(password)), 'utf8')\n    } catch (error) {\n      return reject(error)\n    }\n\n    pbkdf2Async(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512', function (err, data) {\n      if (err) return reject(err)\n      else return resolve(data)\n    })\n  })\n}\n\nfunction mnemonicToSeedHexAsync (mnemonic, password) {\n  return mnemonicToSeedAsync(mnemonic, password)\n    .then(function (buf) { return buf.toString('hex') })\n}\n\nfunction mnemonicToEntropy (mnemonic, wordlist) {\n  wordlist = wordlist || DEFAULT_WORDLIST\n\n  var words = unorm.nfkd(mnemonic).split(' ')\n  if (words.length % 3 !== 0) throw new Error(INVALID_MNEMONIC)\n\n  // convert word indices to 11 bit binary strings\n  var bits = words.map(function (word) {\n    var index = wordlist.indexOf(word)\n    if (index === -1) throw new Error(INVALID_MNEMONIC)\n\n    return lpad(index.toString(2), '0', 11)\n  }).join('')\n\n  // split the binary string into ENT/CS\n  var dividerIndex = Math.floor(bits.length / 33) * 32\n  var entropyBits = bits.slice(0, dividerIndex)\n  var checksumBits = bits.slice(dividerIndex)\n\n  // calculate the checksum and compare\n  var entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte)\n  if (entropyBytes.length < 16) throw new Error(INVALID_ENTROPY)\n  if (entropyBytes.length > 32) throw new Error(INVALID_ENTROPY)\n  if (entropyBytes.length % 4 !== 0) throw new Error(INVALID_ENTROPY)\n\n  var entropy = Buffer.from(entropyBytes)\n  var newChecksum = deriveChecksumBits(entropy)\n  if (newChecksum !== checksumBits) throw new Error(INVALID_CHECKSUM)\n\n  return entropy.toString('hex')\n}\n\nfunction entropyToMnemonic (entropy, wordlist) {\n  if (!Buffer.isBuffer(entropy)) entropy = Buffer.from(entropy, 'hex')\n  wordlist = wordlist || DEFAULT_WORDLIST\n\n  // 128 <= ENT <= 256\n  if (entropy.length < 16) throw new TypeError(INVALID_ENTROPY)\n  if (entropy.length > 32) throw new TypeError(INVALID_ENTROPY)\n  if (entropy.length % 4 !== 0) throw new TypeError(INVALID_ENTROPY)\n\n  var entropyBits = bytesToBinary([].slice.call(entropy))\n  var checksumBits = deriveChecksumBits(entropy)\n\n  var bits = entropyBits + checksumBits\n  var chunks = bits.match(/(.{1,11})/g)\n  var words = chunks.map(function (binary) {\n    var index = binaryToByte(binary)\n    return wordlist[index]\n  })\n\n  return wordlist === JAPANESE_WORDLIST ? words.join('\\u3000') : words.join(' ')\n}\n\nfunction generateMnemonic (strength, rng, wordlist) {\n  strength = strength || 128\n  if (strength % 32 !== 0) throw new TypeError(INVALID_ENTROPY)\n  rng = rng || randomBytes\n\n  return entropyToMnemonic(rng(strength / 8), wordlist)\n}\n\nfunction validateMnemonic (mnemonic, wordlist) {\n  try {\n    mnemonicToEntropy(mnemonic, wordlist)\n  } catch (e) {\n    return false\n  }\n\n  return true\n}\n\nmodule.exports = {\n  mnemonicToSeed: mnemonicToSeed,\n  mnemonicToSeedAsync: mnemonicToSeedAsync,\n  mnemonicToSeedHex: mnemonicToSeedHex,\n  mnemonicToSeedHexAsync: mnemonicToSeedHexAsync,\n  mnemonicToEntropy: mnemonicToEntropy,\n  entropyToMnemonic: entropyToMnemonic,\n  generateMnemonic: generateMnemonic,\n  validateMnemonic: validateMnemonic,\n  wordlists: {\n    EN: ENGLISH_WORDLIST,\n    JA: JAPANESE_WORDLIST,\n\n    chinese_simplified: CHINESE_SIMPLIFIED_WORDLIST,\n    chinese_traditional: CHINESE_TRADITIONAL_WORDLIST,\n    english: ENGLISH_WORDLIST,\n    french: FRENCH_WORDLIST,\n    italian: ITALIAN_WORDLIST,\n    japanese: JAPANESE_WORDLIST,\n    korean: KOREAN_WORDLIST,\n    spanish: SPANISH_WORDLIST\n  }\n}\n"]},"metadata":{},"sourceType":"script"}