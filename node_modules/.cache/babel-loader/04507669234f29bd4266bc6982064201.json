{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar assert_1 = require(\"@0x/assert\");\n\nvar json_schemas_1 = require(\"@0x/json-schemas\");\n\nvar utils_1 = require(\"@0x/utils\");\n\nvar ethereum_types_1 = require(\"ethereum-types\");\n\nvar _ = require(\"lodash\");\n\nvar marshaller_1 = require(\"./marshaller\");\n\nvar types_1 = require(\"./types\");\n\nvar utils_2 = require(\"./utils\");\n\nvar BASE_TEN = 10; // These are unique identifiers contained in the response of the\n// web3_clientVersion call.\n\nvar uniqueVersionIds = {\n  geth: 'Geth',\n  ganache: 'EthereumJS TestRPC'\n};\n/**\n * An alternative to the Web3.js library that provides a consistent, clean, promise-based interface.\n */\n\nvar Web3Wrapper =\n/** @class */\nfunction () {\n  /**\n   * Instantiates a new Web3Wrapper.\n   * @param   provider    The Web3 provider instance you would like the Web3Wrapper to use for interacting with\n   *                      the backing Ethereum node.\n   * @param   callAndTxnDefaults  Override Call and Txn Data defaults sent with RPC requests to the backing Ethereum node.\n   * @return  An instance of the Web3Wrapper class.\n   */\n  function Web3Wrapper(supportedProvider, callAndTxnDefaults) {\n    if (callAndTxnDefaults === void 0) {\n      callAndTxnDefaults = {};\n    }\n    /**\n     * Flag to check if this instance is of type Web3Wrapper\n     */\n\n\n    this.isZeroExWeb3Wrapper = true;\n    this.abiDecoder = new utils_1.AbiDecoder([]);\n    this._supportedProvider = supportedProvider;\n    this._provider = utils_1.providerUtils.standardizeOrThrow(supportedProvider);\n    this._callAndTxnDefaults = callAndTxnDefaults;\n    this._jsonRpcRequestId = 1;\n  }\n  /**\n   * Check if an address is a valid Ethereum address\n   * @param address Address to check\n   * @returns Whether the address is a valid Ethereum address\n   */\n\n\n  Web3Wrapper.isAddress = function (address) {\n    return utils_1.addressUtils.isAddress(address);\n  };\n  /**\n   * A unit amount is defined as the amount of a token above the specified decimal places (integer part).\n   * E.g: If a currency has 18 decimal places, 1e18 or one quintillion of the currency is equivalent\n   * to 1 unit.\n   * @param   amount      The amount in baseUnits that you would like converted to units.\n   * @param   decimals    The number of decimal places the unit amount has.\n   * @return  The amount in units.\n   */\n\n\n  Web3Wrapper.toUnitAmount = function (amount, decimals) {\n    assert_1.assert.isValidBaseUnitAmount('amount', amount);\n    assert_1.assert.isNumber('decimals', decimals);\n    var aUnit = new utils_1.BigNumber(BASE_TEN).pow(decimals);\n    var unit = amount.div(aUnit);\n    return unit;\n  };\n  /**\n   * A baseUnit is defined as the smallest denomination of a token. An amount expressed in baseUnits\n   * is the amount expressed in the smallest denomination.\n   * E.g: 1 unit of a token with 18 decimal places is expressed in baseUnits as 1000000000000000000\n   * @param   amount      The amount of units that you would like converted to baseUnits.\n   * @param   decimals    The number of decimal places the unit amount has.\n   * @return  The amount in baseUnits.\n   */\n\n\n  Web3Wrapper.toBaseUnitAmount = function (amount, decimals) {\n    assert_1.assert.isBigNumber('amount', amount);\n    assert_1.assert.isNumber('decimals', decimals);\n    var unit = new utils_1.BigNumber(BASE_TEN).pow(decimals);\n    var baseUnitAmount = amount.times(unit);\n    var hasDecimals = baseUnitAmount.decimalPlaces() !== 0;\n\n    if (hasDecimals) {\n      throw new Error(\"Invalid unit amount: \" + amount.toString() + \" - Too many decimal places\");\n    }\n\n    return baseUnitAmount;\n  };\n  /**\n   * Convert an Ether amount from ETH to Wei\n   * @param ethAmount Amount of Ether to convert to wei\n   * @returns Amount in wei\n   */\n\n\n  Web3Wrapper.toWei = function (ethAmount) {\n    assert_1.assert.isBigNumber('ethAmount', ethAmount);\n    var ETH_DECIMALS = 18;\n    var balanceWei = Web3Wrapper.toBaseUnitAmount(ethAmount, ETH_DECIMALS);\n    return balanceWei;\n  };\n\n  Web3Wrapper._assertBlockParam = function (blockParam) {\n    if (_.isNumber(blockParam)) {\n      return;\n    } else if (_.isString(blockParam)) {\n      assert_1.assert.doesBelongToStringEnum('blockParam', blockParam, ethereum_types_1.BlockParamLiteral);\n    }\n  };\n\n  Web3Wrapper._assertBlockParamOrString = function (blockParam) {\n    try {\n      Web3Wrapper._assertBlockParam(blockParam);\n    } catch (err) {\n      try {\n        assert_1.assert.isHexString('blockParam', blockParam);\n        return;\n      } catch (err) {\n        throw new Error(\"Expected blockParam to be of type \\\"string | BlockParam\\\", encountered \" + blockParam);\n      }\n    }\n  };\n\n  Web3Wrapper._normalizeTxReceiptStatus = function (status) {\n    // Transaction status might have four values\n    // undefined - Testrpc and other old clients\n    // null - New clients on old transactions\n    // number - Parity\n    // hex - Geth\n    if (_.isString(status)) {\n      return utils_2.utils.convertHexToNumber(status);\n    } else if (status === undefined) {\n      return null;\n    } else {\n      return status;\n    }\n  };\n  /**\n   * Get the contract defaults set to the Web3Wrapper instance\n   * @return  CallAndTxnData defaults (e.g gas, gasPrice, nonce, etc...)\n   */\n\n\n  Web3Wrapper.prototype.getContractDefaults = function () {\n    return this._callAndTxnDefaults;\n  };\n  /**\n   * Retrieve the Web3 provider\n   * @return  Web3 provider instance\n   */\n\n\n  Web3Wrapper.prototype.getProvider = function () {\n    return this._supportedProvider;\n  };\n  /**\n   * Update the used Web3 provider\n   * @param provider The new Web3 provider to be set\n   */\n\n\n  Web3Wrapper.prototype.setProvider = function (supportedProvider) {\n    var provider = utils_1.providerUtils.standardizeOrThrow(supportedProvider);\n    this._provider = provider;\n  };\n  /**\n   * Check whether an address is available through the backing provider. This can be\n   * useful if you want to know whether a user can sign messages or transactions from\n   * a given Ethereum address.\n   * @param senderAddress Address to check availability for\n   * @returns Whether the address is available through the provider.\n   */\n\n\n  Web3Wrapper.prototype.isSenderAddressAvailableAsync = function (senderAddress) {\n    return __awaiter(this, void 0, void 0, function () {\n      var addresses, normalizedAddress;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('senderAddress', senderAddress);\n            return [4\n            /*yield*/\n            , this.getAvailableAddressesAsync()];\n\n          case 1:\n            addresses = _a.sent();\n            normalizedAddress = senderAddress.toLowerCase();\n            return [2\n            /*return*/\n            , _.includes(addresses, normalizedAddress)];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch the backing Ethereum node's version string (e.g `MetaMask/v4.2.0`)\n   * @returns Ethereum node's version string\n   */\n\n\n  Web3Wrapper.prototype.getNodeVersionAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var nodeVersion;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'web3_clientVersion'\n            })];\n\n          case 1:\n            nodeVersion = _a.sent();\n            return [2\n            /*return*/\n            , nodeVersion];\n        }\n      });\n    });\n  };\n  /**\n   * Fetches the networkId of the backing Ethereum node\n   * @returns The network id\n   */\n\n\n  Web3Wrapper.prototype.getNetworkIdAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var networkIdStr, networkId;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'net_version'\n            })];\n\n          case 1:\n            networkIdStr = _a.sent();\n            networkId = _.parseInt(networkIdStr);\n            return [2\n            /*return*/\n            , networkId];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieves the transaction receipt for a given transaction hash if found\n   * @param txHash Transaction hash\n   * @returns The transaction receipt, including it's status (0: failed, 1: succeeded). Returns undefined if transaction not found.\n   */\n\n\n  Web3Wrapper.prototype.getTransactionReceiptIfExistsAsync = function (txHash) {\n    return __awaiter(this, void 0, void 0, function () {\n      var transactionReceiptRpc, transactionReceipt;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isHexString('txHash', txHash);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_getTransactionReceipt',\n              params: [txHash]\n            })];\n\n          case 1:\n            transactionReceiptRpc = _a.sent(); // HACK Parity can return a pending transaction receipt. We check for a non null\n            // block number before continuing with returning a fully realised receipt.\n            // ref: https://github.com/paritytech/parity-ethereum/issues/1180\n\n            if (transactionReceiptRpc !== null && transactionReceiptRpc.blockNumber !== null) {\n              transactionReceiptRpc.status = Web3Wrapper._normalizeTxReceiptStatus(transactionReceiptRpc.status);\n              transactionReceipt = marshaller_1.marshaller.unmarshalTransactionReceipt(transactionReceiptRpc);\n              return [2\n              /*return*/\n              , transactionReceipt];\n            } else {\n              return [2\n              /*return*/\n              , undefined];\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieves the transaction data for a given transaction\n   * @param txHash Transaction hash\n   * @returns The raw transaction data\n   */\n\n\n  Web3Wrapper.prototype.getTransactionByHashAsync = function (txHash) {\n    return __awaiter(this, void 0, void 0, function () {\n      var transactionRpc, transaction;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isHexString('txHash', txHash);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_getTransactionByHash',\n              params: [txHash]\n            })];\n\n          case 1:\n            transactionRpc = _a.sent();\n            transaction = marshaller_1.marshaller.unmarshalTransaction(transactionRpc);\n            return [2\n            /*return*/\n            , transaction];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieves an accounts Ether balance in wei\n   * @param owner Account whose balance you wish to check\n   * @param defaultBlock The block depth at which to fetch the balance (default=latest)\n   * @returns Balance in wei\n   */\n\n\n  Web3Wrapper.prototype.getBalanceInWeiAsync = function (owner, defaultBlock) {\n    return __awaiter(this, void 0, void 0, function () {\n      var marshalledDefaultBlock, encodedOwner, balanceInWei;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('owner', owner);\n\n            if (defaultBlock !== undefined) {\n              Web3Wrapper._assertBlockParam(defaultBlock);\n            }\n\n            marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n            encodedOwner = marshaller_1.marshaller.marshalAddress(owner);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_getBalance',\n              params: [encodedOwner, marshalledDefaultBlock]\n            })];\n\n          case 1:\n            balanceInWei = _a.sent(); // Rewrap in a new BigNumber\n\n            return [2\n            /*return*/\n            , new utils_1.BigNumber(balanceInWei)];\n        }\n      });\n    });\n  };\n  /**\n   * Check if a contract exists at a given address\n   * @param address Address to which to check\n   * @returns Whether or not contract code was found at the supplied address\n   */\n\n\n  Web3Wrapper.prototype.doesContractExistAtAddressAsync = function (address) {\n    return __awaiter(this, void 0, void 0, function () {\n      var code, isCodeEmpty;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('address', address);\n            return [4\n            /*yield*/\n            , this.getContractCodeAsync(address)];\n\n          case 1:\n            code = _a.sent();\n            isCodeEmpty = /^0x0{0,40}$/i.test(code);\n            return [2\n            /*return*/\n            , !isCodeEmpty];\n        }\n      });\n    });\n  };\n  /**\n   * Gets the contract code by address\n   * @param  address Address of the contract\n   * @param defaultBlock Block height at which to make the call. Defaults to `latest`\n   * @return Code of the contract\n   */\n\n\n  Web3Wrapper.prototype.getContractCodeAsync = function (address, defaultBlock) {\n    return __awaiter(this, void 0, void 0, function () {\n      var marshalledDefaultBlock, encodedAddress, code;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('address', address);\n\n            if (defaultBlock !== undefined) {\n              Web3Wrapper._assertBlockParam(defaultBlock);\n            }\n\n            marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n            encodedAddress = marshaller_1.marshaller.marshalAddress(address);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_getCode',\n              params: [encodedAddress, marshalledDefaultBlock]\n            })];\n\n          case 1:\n            code = _a.sent();\n            return [2\n            /*return*/\n            , code];\n        }\n      });\n    });\n  };\n  /**\n   * Gets the debug trace of a transaction\n   * @param  txHash Hash of the transactuon to get a trace for\n   * @param  traceParams Config object allowing you to specify if you need memory/storage/stack traces.\n   * @return Transaction trace\n   */\n\n\n  Web3Wrapper.prototype.getTransactionTraceAsync = function (txHash, traceParams) {\n    return __awaiter(this, void 0, void 0, function () {\n      var trace;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isHexString('txHash', txHash);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'debug_traceTransaction',\n              params: [txHash, traceParams]\n            })];\n\n          case 1:\n            trace = _a.sent();\n            return [2\n            /*return*/\n            , trace];\n        }\n      });\n    });\n  };\n  /**\n   * Sign a message with a specific address's private key (`eth_sign`)\n   * @param address Address of signer\n   * @param message Message to sign\n   * @returns Signature string (might be VRS or RSV depending on the Signer)\n   */\n\n\n  Web3Wrapper.prototype.signMessageAsync = function (address, message) {\n    return __awaiter(this, void 0, void 0, function () {\n      var signData;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('address', address);\n            assert_1.assert.isString('message', message); // TODO: Should this be stricter? Hex string?\n\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_sign',\n              params: [address, message]\n            })];\n\n          case 1:\n            signData = _a.sent();\n            return [2\n            /*return*/\n            , signData];\n        }\n      });\n    });\n  };\n  /**\n   * Sign an EIP712 typed data message with a specific address's private key (`eth_signTypedData`)\n   * @param address Address of signer\n   * @param typedData Typed data message to sign\n   * @returns Signature string (as RSV)\n   */\n\n\n  Web3Wrapper.prototype.signTypedDataAsync = function (address, typedData) {\n    return __awaiter(this, void 0, void 0, function () {\n      var signData;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isETHAddressHex('address', address);\n            assert_1.assert.doesConformToSchema('typedData', typedData, json_schemas_1.schemas.eip712TypedDataSchema);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_signTypedData',\n              params: [address, typedData]\n            })];\n\n          case 1:\n            signData = _a.sent();\n            return [2\n            /*return*/\n            , signData];\n        }\n      });\n    });\n  };\n  /**\n   * Fetches the latest block number\n   * @returns Block number\n   */\n\n\n  Web3Wrapper.prototype.getBlockNumberAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var blockNumberHex, blockNumber;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_blockNumber',\n              params: []\n            })];\n\n          case 1:\n            blockNumberHex = _a.sent();\n            blockNumber = utils_2.utils.convertHexToNumberOrNull(blockNumberHex);\n            return [2\n            /*return*/\n            , blockNumber];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a specific Ethereum block without transaction data\n   * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n   * @returns The requested block without transaction data, or undefined if block was not found\n   * (e.g the node isn't fully synced, there was a block re-org and the requested block was uncles, etc...)\n   */\n\n\n  Web3Wrapper.prototype.getBlockIfExistsAsync = function (blockParam) {\n    return __awaiter(this, void 0, void 0, function () {\n      var encodedBlockParam, method, shouldIncludeTransactionData, blockWithoutTransactionDataWithHexValuesOrNull, blockWithoutTransactionDataIfExists;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            Web3Wrapper._assertBlockParamOrString(blockParam);\n\n            encodedBlockParam = marshaller_1.marshaller.marshalBlockParam(blockParam);\n            method = utils_2.utils.isHexStrict(blockParam) ? 'eth_getBlockByHash' : 'eth_getBlockByNumber';\n            shouldIncludeTransactionData = false;\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: method,\n              params: [encodedBlockParam, shouldIncludeTransactionData]\n            })];\n\n          case 1:\n            blockWithoutTransactionDataWithHexValuesOrNull = _a.sent();\n\n            if (blockWithoutTransactionDataWithHexValuesOrNull !== null) {\n              blockWithoutTransactionDataIfExists = marshaller_1.marshaller.unmarshalIntoBlockWithoutTransactionData(blockWithoutTransactionDataWithHexValuesOrNull);\n            }\n\n            return [2\n            /*return*/\n            , blockWithoutTransactionDataIfExists];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a specific Ethereum block with transaction data\n   * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n   * @returns The requested block with transaction data\n   */\n\n\n  Web3Wrapper.prototype.getBlockWithTransactionDataAsync = function (blockParam) {\n    return __awaiter(this, void 0, void 0, function () {\n      var encodedBlockParam, method, shouldIncludeTransactionData, blockWithTransactionDataWithHexValues, blockWithoutTransactionData;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            Web3Wrapper._assertBlockParamOrString(blockParam);\n\n            encodedBlockParam = blockParam;\n\n            if (_.isNumber(blockParam)) {\n              encodedBlockParam = utils_2.utils.numberToHex(blockParam);\n            }\n\n            method = utils_2.utils.isHexStrict(blockParam) ? 'eth_getBlockByHash' : 'eth_getBlockByNumber';\n            shouldIncludeTransactionData = true;\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: method,\n              params: [encodedBlockParam, shouldIncludeTransactionData]\n            })];\n\n          case 1:\n            blockWithTransactionDataWithHexValues = _a.sent();\n            blockWithoutTransactionData = marshaller_1.marshaller.unmarshalIntoBlockWithTransactionData(blockWithTransactionDataWithHexValues);\n            return [2\n            /*return*/\n            , blockWithoutTransactionData];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a block's timestamp\n   * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n   * @returns The block's timestamp\n   */\n\n\n  Web3Wrapper.prototype.getBlockTimestampAsync = function (blockParam) {\n    return __awaiter(this, void 0, void 0, function () {\n      var blockIfExists;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            Web3Wrapper._assertBlockParamOrString(blockParam);\n\n            return [4\n            /*yield*/\n            , this.getBlockIfExistsAsync(blockParam)];\n\n          case 1:\n            blockIfExists = _a.sent();\n\n            if (blockIfExists === undefined) {\n              throw new Error(\"Failed to fetch block with blockParam: \" + JSON.stringify(blockParam));\n            }\n\n            return [2\n            /*return*/\n            , blockIfExists.timestamp];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieve the user addresses available through the backing provider\n   * @returns Available user addresses\n   */\n\n\n  Web3Wrapper.prototype.getAvailableAddressesAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var addresses, normalizedAddresses;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_accounts',\n              params: []\n            })];\n\n          case 1:\n            addresses = _a.sent();\n            normalizedAddresses = _.map(addresses, function (address) {\n              return address.toLowerCase();\n            });\n            return [2\n            /*return*/\n            , normalizedAddresses];\n        }\n      });\n    });\n  };\n  /**\n   * Take a snapshot of the blockchain state on a TestRPC/Ganache local node\n   * @returns The snapshot id. This can be used to revert to this snapshot\n   */\n\n\n  Web3Wrapper.prototype.takeSnapshotAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var snapshotId, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = Number;\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'evm_snapshot',\n              params: []\n            })];\n\n          case 1:\n            snapshotId = _a.apply(void 0, [_b.sent()]);\n            return [2\n            /*return*/\n            , snapshotId];\n        }\n      });\n    });\n  };\n  /**\n   * Revert the blockchain state to a previous snapshot state on TestRPC/Ganache local node\n   * @param snapshotId snapshot id to revert to\n   * @returns Whether the revert was successful\n   */\n\n\n  Web3Wrapper.prototype.revertSnapshotAsync = function (snapshotId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var didRevert;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isNumber('snapshotId', snapshotId);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'evm_revert',\n              params: [snapshotId]\n            })];\n\n          case 1:\n            didRevert = _a.sent();\n            return [2\n            /*return*/\n            , didRevert];\n        }\n      });\n    });\n  };\n  /**\n   * Mine a block on a TestRPC/Ganache local node\n   */\n\n\n  Web3Wrapper.prototype.mineBlockAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'evm_mine',\n              params: []\n            })];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Increase the next blocks timestamp on TestRPC/Ganache or Geth local node.\n   * Will throw if provider is neither TestRPC/Ganache or Geth.\n   * @param timeDelta Amount of time to add in seconds\n   */\n\n\n  Web3Wrapper.prototype.increaseTimeAsync = function (timeDelta) {\n    return __awaiter(this, void 0, void 0, function () {\n      var version;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isNumber('timeDelta', timeDelta);\n            return [4\n            /*yield*/\n            , this.getNodeVersionAsync()];\n\n          case 1:\n            version = _a.sent();\n\n            if (_.includes(version, uniqueVersionIds.geth)) {\n              return [2\n              /*return*/\n              , this.sendRawPayloadAsync({\n                method: 'debug_increaseTime',\n                params: [timeDelta]\n              })];\n            } else if (_.includes(version, uniqueVersionIds.ganache)) {\n              return [2\n              /*return*/\n              , this.sendRawPayloadAsync({\n                method: 'evm_increaseTime',\n                params: [timeDelta]\n              })];\n            } else {\n              throw new Error(\"Unknown client version: \" + version);\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieve smart contract logs for a given filter\n   * @param filter Parameters by which to filter which logs to retrieve\n   * @returns The corresponding log entries\n   */\n\n\n  Web3Wrapper.prototype.getLogsAsync = function (filter) {\n    return __awaiter(this, void 0, void 0, function () {\n      var fromBlock, toBlock, serializedFilter, payload, rawLogs, formattedLogs;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (filter.blockHash !== undefined && (filter.fromBlock !== undefined || filter.toBlock !== undefined)) {\n              throw new Error(\"Cannot specify 'blockHash' as well as 'fromBlock'/'toBlock' in the filter supplied to 'getLogsAsync'\");\n            }\n\n            fromBlock = filter.fromBlock;\n\n            if (_.isNumber(fromBlock)) {\n              fromBlock = utils_2.utils.numberToHex(fromBlock);\n            }\n\n            toBlock = filter.toBlock;\n\n            if (_.isNumber(toBlock)) {\n              toBlock = utils_2.utils.numberToHex(toBlock);\n            }\n\n            serializedFilter = __assign({}, filter, {\n              fromBlock: fromBlock,\n              toBlock: toBlock\n            });\n            payload = {\n              method: 'eth_getLogs',\n              params: [serializedFilter]\n            };\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync(payload)];\n\n          case 1:\n            rawLogs = _a.sent();\n            formattedLogs = _.map(rawLogs, marshaller_1.marshaller.unmarshalLog.bind(marshaller_1.marshaller));\n            return [2\n            /*return*/\n            , formattedLogs];\n        }\n      });\n    });\n  };\n  /**\n   * Calculate the estimated gas cost for a given transaction\n   * @param txData Transaction data\n   * @returns Estimated gas cost\n   */\n\n\n  Web3Wrapper.prototype.estimateGasAsync = function (txData) {\n    return __awaiter(this, void 0, void 0, function () {\n      var txDataHex, gasHex, gas;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.doesConformToSchema('txData', txData, json_schemas_1.schemas.txDataSchema, [json_schemas_1.schemas.addressSchema, json_schemas_1.schemas.numberSchema, json_schemas_1.schemas.jsNumber]);\n            txDataHex = marshaller_1.marshaller.marshalTxData(txData);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_estimateGas',\n              params: [txDataHex]\n            })];\n\n          case 1:\n            gasHex = _a.sent();\n            gas = utils_2.utils.convertHexToNumber(gasHex);\n            return [2\n            /*return*/\n            , gas];\n        }\n      });\n    });\n  };\n  /**\n   * Call a smart contract method at a given block height\n   * @param callData Call data\n   * @param defaultBlock Block height at which to make the call. Defaults to `latest`\n   * @returns The raw call result\n   */\n\n\n  Web3Wrapper.prototype.callAsync = function (callData, defaultBlock) {\n    return __awaiter(this, void 0, void 0, function () {\n      var marshalledDefaultBlock, callDataHex, rawCallResult;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.doesConformToSchema('callData', callData, json_schemas_1.schemas.callDataSchema, [json_schemas_1.schemas.addressSchema, json_schemas_1.schemas.numberSchema, json_schemas_1.schemas.jsNumber]);\n\n            if (defaultBlock !== undefined) {\n              Web3Wrapper._assertBlockParam(defaultBlock);\n            }\n\n            marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n            callDataHex = marshaller_1.marshaller.marshalCallData(callData);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_call',\n              params: [callDataHex, marshalledDefaultBlock]\n            })];\n\n          case 1:\n            rawCallResult = _a.sent();\n            return [2\n            /*return*/\n            , rawCallResult];\n        }\n      });\n    });\n  };\n  /**\n   * Send a transaction\n   * @param txData Transaction data\n   * @returns Transaction hash\n   */\n\n\n  Web3Wrapper.prototype.sendTransactionAsync = function (txData) {\n    return __awaiter(this, void 0, void 0, function () {\n      var txDataHex, txHash;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.doesConformToSchema('txData', txData, json_schemas_1.schemas.txDataSchema, [json_schemas_1.schemas.addressSchema, json_schemas_1.schemas.numberSchema, json_schemas_1.schemas.jsNumber]);\n            txDataHex = marshaller_1.marshaller.marshalTxData(txData);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'eth_sendTransaction',\n              params: [txDataHex]\n            })];\n\n          case 1:\n            txHash = _a.sent();\n            return [2\n            /*return*/\n            , txHash];\n        }\n      });\n    });\n  };\n  /**\n   * Waits for a transaction to be mined and returns the transaction receipt.\n   * Note that just because a transaction was mined does not mean it was\n   * successful. You need to check the status code of the transaction receipt\n   * to find out if it was successful, or use the helper method\n   * awaitTransactionSuccessAsync.\n   * @param   txHash            Transaction hash\n   * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.\n   * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.\n   * @return  Transaction receipt with decoded log args.\n   */\n\n\n  Web3Wrapper.prototype.awaitTransactionMinedAsync = function (txHash, pollingIntervalMs, timeoutMs) {\n    if (pollingIntervalMs === void 0) {\n      pollingIntervalMs = 1000;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var transactionReceipt, logsWithDecodedArgs, transactionReceiptWithDecodedLogArgs, wasTimeoutExceeded, txReceiptPromise, txReceipt;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isHexString('txHash', txHash);\n            assert_1.assert.isNumber('pollingIntervalMs', pollingIntervalMs);\n\n            if (timeoutMs !== undefined) {\n              assert_1.assert.isNumber('timeoutMs', timeoutMs);\n            }\n\n            return [4\n            /*yield*/\n            , this.getTransactionReceiptIfExistsAsync(txHash)];\n\n          case 1:\n            transactionReceipt = _a.sent();\n\n            if (transactionReceipt !== undefined) {\n              logsWithDecodedArgs = _.map(transactionReceipt.logs, this.abiDecoder.tryToDecodeLogOrNoop.bind(this.abiDecoder));\n              transactionReceiptWithDecodedLogArgs = __assign({}, transactionReceipt, {\n                logs: logsWithDecodedArgs\n              });\n              return [2\n              /*return*/\n              , transactionReceiptWithDecodedLogArgs];\n            }\n\n            wasTimeoutExceeded = false;\n\n            if (timeoutMs) {\n              setTimeout(function () {\n                return wasTimeoutExceeded = true;\n              }, timeoutMs);\n            }\n\n            txReceiptPromise = new Promise(function (resolve, reject) {\n              var intervalId = utils_1.intervalUtils.setAsyncExcludingInterval(function () {\n                return __awaiter(_this, void 0, void 0, function () {\n                  var logsWithDecodedArgs, transactionReceiptWithDecodedLogArgs;\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        if (wasTimeoutExceeded) {\n                          utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                          return [2\n                          /*return*/\n                          , reject(types_1.Web3WrapperErrors.TransactionMiningTimeout)];\n                        }\n\n                        return [4\n                        /*yield*/\n                        , this.getTransactionReceiptIfExistsAsync(txHash)];\n\n                      case 1:\n                        transactionReceipt = _a.sent();\n\n                        if (transactionReceipt !== undefined) {\n                          utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                          logsWithDecodedArgs = _.map(transactionReceipt.logs, this.abiDecoder.tryToDecodeLogOrNoop.bind(this.abiDecoder));\n                          transactionReceiptWithDecodedLogArgs = __assign({}, transactionReceipt, {\n                            logs: logsWithDecodedArgs\n                          });\n                          resolve(transactionReceiptWithDecodedLogArgs);\n                        }\n\n                        return [2\n                        /*return*/\n                        ];\n                    }\n                  });\n                });\n              }, pollingIntervalMs, function (err) {\n                utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                reject(err);\n              });\n            });\n            return [4\n            /*yield*/\n            , txReceiptPromise];\n\n          case 2:\n            txReceipt = _a.sent();\n            return [2\n            /*return*/\n            , txReceipt];\n        }\n      });\n    });\n  };\n  /**\n   * Waits for a transaction to be mined and returns the transaction receipt.\n   * Unlike awaitTransactionMinedAsync, it will throw if the receipt has a\n   * status that is not equal to 1. A status of 0 or null indicates that the\n   * transaction was mined, but failed. See:\n   * https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethgettransactionreceipt\n   * @param   txHash            Transaction hash\n   * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.\n   * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.\n   * @return  Transaction receipt with decoded log args.\n   */\n\n\n  Web3Wrapper.prototype.awaitTransactionSuccessAsync = function (txHash, pollingIntervalMs, timeoutMs) {\n    if (pollingIntervalMs === void 0) {\n      pollingIntervalMs = 1000;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var receipt;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.awaitTransactionMinedAsync(txHash, pollingIntervalMs, timeoutMs)];\n\n          case 1:\n            receipt = _a.sent();\n\n            if (receipt.status !== 1) {\n              throw new Error(\"Transaction failed: \" + txHash);\n            }\n\n            return [2\n            /*return*/\n            , receipt];\n        }\n      });\n    });\n  };\n  /**\n   * Calls the 'debug_setHead' JSON RPC method, which sets the current head of\n   * the local chain by block number. Note, this is a destructive action and\n   * may severely damage your chain. Use with extreme caution. As of now, this\n   * is only supported by Geth. It sill throw if the 'debug_setHead' method is\n   * not supported.\n   * @param  blockNumber The block number to reset to.\n   */\n\n\n  Web3Wrapper.prototype.setHeadAsync = function (blockNumber) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            assert_1.assert.isNumber('blockNumber', blockNumber);\n            return [4\n            /*yield*/\n            , this.sendRawPayloadAsync({\n              method: 'debug_setHead',\n              params: [utils_2.utils.numberToHex(blockNumber)]\n            })];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Sends a raw Ethereum JSON RPC payload and returns the response's `result` key\n   * @param payload A partial JSON RPC payload. No need to include version, id, params (if none needed)\n   * @return The contents nested under the result key of the response body\n   */\n\n\n  Web3Wrapper.prototype.sendRawPayloadAsync = function (payload) {\n    return __awaiter(this, void 0, void 0, function () {\n      var sendAsync, payloadWithDefaults, response, result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            sendAsync = this._provider.sendAsync.bind(this._provider);\n            payloadWithDefaults = __assign({\n              id: this._jsonRpcRequestId++,\n              params: [],\n              jsonrpc: '2.0'\n            }, payload);\n            return [4\n            /*yield*/\n            , utils_1.promisify(sendAsync)(payloadWithDefaults)];\n\n          case 1:\n            response = _a.sent();\n\n            if (response.error) {\n              throw new Error(response.error.message);\n            }\n\n            result = response.result;\n            return [2\n            /*return*/\n            , result];\n        }\n      });\n    });\n  };\n  /**\n   * Returns either NodeType.Geth or NodeType.Ganache depending on the type of\n   * the backing Ethereum node. Throws for any other type of node.\n   */\n\n\n  Web3Wrapper.prototype.getNodeTypeAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var version;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.getNodeVersionAsync()];\n\n          case 1:\n            version = _a.sent();\n\n            if (_.includes(version, uniqueVersionIds.geth)) {\n              return [2\n              /*return*/\n              , types_1.NodeType.Geth];\n            } else if (_.includes(version, uniqueVersionIds.ganache)) {\n              return [2\n              /*return*/\n              , types_1.NodeType.Ganache];\n            } else {\n              throw new Error(\"Unknown client version: \" + version);\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return Web3Wrapper;\n}(); // tslint:disable-line:max-file-line-count\n\n\nexports.Web3Wrapper = Web3Wrapper;","map":{"version":3,"sources":["../../src/web3_wrapper.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar assert_1 = require(\"@0x/assert\");\nvar json_schemas_1 = require(\"@0x/json-schemas\");\nvar utils_1 = require(\"@0x/utils\");\nvar ethereum_types_1 = require(\"ethereum-types\");\nvar _ = require(\"lodash\");\nvar marshaller_1 = require(\"./marshaller\");\nvar types_1 = require(\"./types\");\nvar utils_2 = require(\"./utils\");\nvar BASE_TEN = 10;\n// These are unique identifiers contained in the response of the\n// web3_clientVersion call.\nvar uniqueVersionIds = {\n    geth: 'Geth',\n    ganache: 'EthereumJS TestRPC',\n};\n/**\n * An alternative to the Web3.js library that provides a consistent, clean, promise-based interface.\n */\nvar Web3Wrapper = /** @class */ (function () {\n    /**\n     * Instantiates a new Web3Wrapper.\n     * @param   provider    The Web3 provider instance you would like the Web3Wrapper to use for interacting with\n     *                      the backing Ethereum node.\n     * @param   callAndTxnDefaults  Override Call and Txn Data defaults sent with RPC requests to the backing Ethereum node.\n     * @return  An instance of the Web3Wrapper class.\n     */\n    function Web3Wrapper(supportedProvider, callAndTxnDefaults) {\n        if (callAndTxnDefaults === void 0) { callAndTxnDefaults = {}; }\n        /**\n         * Flag to check if this instance is of type Web3Wrapper\n         */\n        this.isZeroExWeb3Wrapper = true;\n        this.abiDecoder = new utils_1.AbiDecoder([]);\n        this._supportedProvider = supportedProvider;\n        this._provider = utils_1.providerUtils.standardizeOrThrow(supportedProvider);\n        this._callAndTxnDefaults = callAndTxnDefaults;\n        this._jsonRpcRequestId = 1;\n    }\n    /**\n     * Check if an address is a valid Ethereum address\n     * @param address Address to check\n     * @returns Whether the address is a valid Ethereum address\n     */\n    Web3Wrapper.isAddress = function (address) {\n        return utils_1.addressUtils.isAddress(address);\n    };\n    /**\n     * A unit amount is defined as the amount of a token above the specified decimal places (integer part).\n     * E.g: If a currency has 18 decimal places, 1e18 or one quintillion of the currency is equivalent\n     * to 1 unit.\n     * @param   amount      The amount in baseUnits that you would like converted to units.\n     * @param   decimals    The number of decimal places the unit amount has.\n     * @return  The amount in units.\n     */\n    Web3Wrapper.toUnitAmount = function (amount, decimals) {\n        assert_1.assert.isValidBaseUnitAmount('amount', amount);\n        assert_1.assert.isNumber('decimals', decimals);\n        var aUnit = new utils_1.BigNumber(BASE_TEN).pow(decimals);\n        var unit = amount.div(aUnit);\n        return unit;\n    };\n    /**\n     * A baseUnit is defined as the smallest denomination of a token. An amount expressed in baseUnits\n     * is the amount expressed in the smallest denomination.\n     * E.g: 1 unit of a token with 18 decimal places is expressed in baseUnits as 1000000000000000000\n     * @param   amount      The amount of units that you would like converted to baseUnits.\n     * @param   decimals    The number of decimal places the unit amount has.\n     * @return  The amount in baseUnits.\n     */\n    Web3Wrapper.toBaseUnitAmount = function (amount, decimals) {\n        assert_1.assert.isBigNumber('amount', amount);\n        assert_1.assert.isNumber('decimals', decimals);\n        var unit = new utils_1.BigNumber(BASE_TEN).pow(decimals);\n        var baseUnitAmount = amount.times(unit);\n        var hasDecimals = baseUnitAmount.decimalPlaces() !== 0;\n        if (hasDecimals) {\n            throw new Error(\"Invalid unit amount: \" + amount.toString() + \" - Too many decimal places\");\n        }\n        return baseUnitAmount;\n    };\n    /**\n     * Convert an Ether amount from ETH to Wei\n     * @param ethAmount Amount of Ether to convert to wei\n     * @returns Amount in wei\n     */\n    Web3Wrapper.toWei = function (ethAmount) {\n        assert_1.assert.isBigNumber('ethAmount', ethAmount);\n        var ETH_DECIMALS = 18;\n        var balanceWei = Web3Wrapper.toBaseUnitAmount(ethAmount, ETH_DECIMALS);\n        return balanceWei;\n    };\n    Web3Wrapper._assertBlockParam = function (blockParam) {\n        if (_.isNumber(blockParam)) {\n            return;\n        }\n        else if (_.isString(blockParam)) {\n            assert_1.assert.doesBelongToStringEnum('blockParam', blockParam, ethereum_types_1.BlockParamLiteral);\n        }\n    };\n    Web3Wrapper._assertBlockParamOrString = function (blockParam) {\n        try {\n            Web3Wrapper._assertBlockParam(blockParam);\n        }\n        catch (err) {\n            try {\n                assert_1.assert.isHexString('blockParam', blockParam);\n                return;\n            }\n            catch (err) {\n                throw new Error(\"Expected blockParam to be of type \\\"string | BlockParam\\\", encountered \" + blockParam);\n            }\n        }\n    };\n    Web3Wrapper._normalizeTxReceiptStatus = function (status) {\n        // Transaction status might have four values\n        // undefined - Testrpc and other old clients\n        // null - New clients on old transactions\n        // number - Parity\n        // hex - Geth\n        if (_.isString(status)) {\n            return utils_2.utils.convertHexToNumber(status);\n        }\n        else if (status === undefined) {\n            return null;\n        }\n        else {\n            return status;\n        }\n    };\n    /**\n     * Get the contract defaults set to the Web3Wrapper instance\n     * @return  CallAndTxnData defaults (e.g gas, gasPrice, nonce, etc...)\n     */\n    Web3Wrapper.prototype.getContractDefaults = function () {\n        return this._callAndTxnDefaults;\n    };\n    /**\n     * Retrieve the Web3 provider\n     * @return  Web3 provider instance\n     */\n    Web3Wrapper.prototype.getProvider = function () {\n        return this._supportedProvider;\n    };\n    /**\n     * Update the used Web3 provider\n     * @param provider The new Web3 provider to be set\n     */\n    Web3Wrapper.prototype.setProvider = function (supportedProvider) {\n        var provider = utils_1.providerUtils.standardizeOrThrow(supportedProvider);\n        this._provider = provider;\n    };\n    /**\n     * Check whether an address is available through the backing provider. This can be\n     * useful if you want to know whether a user can sign messages or transactions from\n     * a given Ethereum address.\n     * @param senderAddress Address to check availability for\n     * @returns Whether the address is available through the provider.\n     */\n    Web3Wrapper.prototype.isSenderAddressAvailableAsync = function (senderAddress) {\n        return __awaiter(this, void 0, void 0, function () {\n            var addresses, normalizedAddress;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isETHAddressHex('senderAddress', senderAddress);\n                        return [4 /*yield*/, this.getAvailableAddressesAsync()];\n                    case 1:\n                        addresses = _a.sent();\n                        normalizedAddress = senderAddress.toLowerCase();\n                        return [2 /*return*/, _.includes(addresses, normalizedAddress)];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch the backing Ethereum node's version string (e.g `MetaMask/v4.2.0`)\n     * @returns Ethereum node's version string\n     */\n    Web3Wrapper.prototype.getNodeVersionAsync = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var nodeVersion;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.sendRawPayloadAsync({ method: 'web3_clientVersion' })];\n                    case 1:\n                        nodeVersion = _a.sent();\n                        return [2 /*return*/, nodeVersion];\n                }\n            });\n        });\n    };\n    /**\n     * Fetches the networkId of the backing Ethereum node\n     * @returns The network id\n     */\n    Web3Wrapper.prototype.getNetworkIdAsync = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var networkIdStr, networkId;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.sendRawPayloadAsync({ method: 'net_version' })];\n                    case 1:\n                        networkIdStr = _a.sent();\n                        networkId = _.parseInt(networkIdStr);\n                        return [2 /*return*/, networkId];\n                }\n            });\n        });\n    };\n    /**\n     * Retrieves the transaction receipt for a given transaction hash if found\n     * @param txHash Transaction hash\n     * @returns The transaction receipt, including it's status (0: failed, 1: succeeded). Returns undefined if transaction not found.\n     */\n    Web3Wrapper.prototype.getTransactionReceiptIfExistsAsync = function (txHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var transactionReceiptRpc, transactionReceipt;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isHexString('txHash', txHash);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: 'eth_getTransactionReceipt',\n                                params: [txHash],\n                            })];\n                    case 1:\n                        transactionReceiptRpc = _a.sent();\n                        // HACK Parity can return a pending transaction receipt. We check for a non null\n                        // block number before continuing with returning a fully realised receipt.\n                        // ref: https://github.com/paritytech/parity-ethereum/issues/1180\n                        if (transactionReceiptRpc !== null && transactionReceiptRpc.blockNumber !== null) {\n                            transactionReceiptRpc.status = Web3Wrapper._normalizeTxReceiptStatus(transactionReceiptRpc.status);\n                            transactionReceipt = marshaller_1.marshaller.unmarshalTransactionReceipt(transactionReceiptRpc);\n                            return [2 /*return*/, transactionReceipt];\n                        }\n                        else {\n                            return [2 /*return*/, undefined];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Retrieves the transaction data for a given transaction\n     * @param txHash Transaction hash\n     * @returns The raw transaction data\n     */\n    Web3Wrapper.prototype.getTransactionByHashAsync = function (txHash) {\n        return __awaiter(this, void 0, void 0, function () {\n            var transactionRpc, transaction;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isHexString('txHash', txHash);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: 'eth_getTransactionByHash',\n                                params: [txHash],\n                            })];\n                    case 1:\n                        transactionRpc = _a.sent();\n                        transaction = marshaller_1.marshaller.unmarshalTransaction(transactionRpc);\n                        return [2 /*return*/, transaction];\n                }\n            });\n        });\n    };\n    /**\n     * Retrieves an accounts Ether balance in wei\n     * @param owner Account whose balance you wish to check\n     * @param defaultBlock The block depth at which to fetch the balance (default=latest)\n     * @returns Balance in wei\n     */\n    Web3Wrapper.prototype.getBalanceInWeiAsync = function (owner, defaultBlock) {\n        return __awaiter(this, void 0, void 0, function () {\n            var marshalledDefaultBlock, encodedOwner, balanceInWei;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isETHAddressHex('owner', owner);\n                        if (defaultBlock !== undefined) {\n                            Web3Wrapper._assertBlockParam(defaultBlock);\n                        }\n                        marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n                        encodedOwner = marshaller_1.marshaller.marshalAddress(owner);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: 'eth_getBalance',\n                                params: [encodedOwner, marshalledDefaultBlock],\n                            })];\n                    case 1:\n                        balanceInWei = _a.sent();\n                        // Rewrap in a new BigNumber\n                        return [2 /*return*/, new utils_1.BigNumber(balanceInWei)];\n                }\n            });\n        });\n    };\n    /**\n     * Check if a contract exists at a given address\n     * @param address Address to which to check\n     * @returns Whether or not contract code was found at the supplied address\n     */\n    Web3Wrapper.prototype.doesContractExistAtAddressAsync = function (address) {\n        return __awaiter(this, void 0, void 0, function () {\n            var code, isCodeEmpty;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isETHAddressHex('address', address);\n                        return [4 /*yield*/, this.getContractCodeAsync(address)];\n                    case 1:\n                        code = _a.sent();\n                        isCodeEmpty = /^0x0{0,40}$/i.test(code);\n                        return [2 /*return*/, !isCodeEmpty];\n                }\n            });\n        });\n    };\n    /**\n     * Gets the contract code by address\n     * @param  address Address of the contract\n     * @param defaultBlock Block height at which to make the call. Defaults to `latest`\n     * @return Code of the contract\n     */\n    Web3Wrapper.prototype.getContractCodeAsync = function (address, defaultBlock) {\n        return __awaiter(this, void 0, void 0, function () {\n            var marshalledDefaultBlock, encodedAddress, code;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isETHAddressHex('address', address);\n                        if (defaultBlock !== undefined) {\n                            Web3Wrapper._assertBlockParam(defaultBlock);\n                        }\n                        marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n                        encodedAddress = marshaller_1.marshaller.marshalAddress(address);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: 'eth_getCode',\n                                params: [encodedAddress, marshalledDefaultBlock],\n                            })];\n                    case 1:\n                        code = _a.sent();\n                        return [2 /*return*/, code];\n                }\n            });\n        });\n    };\n    /**\n     * Gets the debug trace of a transaction\n     * @param  txHash Hash of the transactuon to get a trace for\n     * @param  traceParams Config object allowing you to specify if you need memory/storage/stack traces.\n     * @return Transaction trace\n     */\n    Web3Wrapper.prototype.getTransactionTraceAsync = function (txHash, traceParams) {\n        return __awaiter(this, void 0, void 0, function () {\n            var trace;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isHexString('txHash', txHash);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: 'debug_traceTransaction',\n                                params: [txHash, traceParams],\n                            })];\n                    case 1:\n                        trace = _a.sent();\n                        return [2 /*return*/, trace];\n                }\n            });\n        });\n    };\n    /**\n     * Sign a message with a specific address's private key (`eth_sign`)\n     * @param address Address of signer\n     * @param message Message to sign\n     * @returns Signature string (might be VRS or RSV depending on the Signer)\n     */\n    Web3Wrapper.prototype.signMessageAsync = function (address, message) {\n        return __awaiter(this, void 0, void 0, function () {\n            var signData;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isETHAddressHex('address', address);\n                        assert_1.assert.isString('message', message); // TODO: Should this be stricter? Hex string?\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: 'eth_sign',\n                                params: [address, message],\n                            })];\n                    case 1:\n                        signData = _a.sent();\n                        return [2 /*return*/, signData];\n                }\n            });\n        });\n    };\n    /**\n     * Sign an EIP712 typed data message with a specific address's private key (`eth_signTypedData`)\n     * @param address Address of signer\n     * @param typedData Typed data message to sign\n     * @returns Signature string (as RSV)\n     */\n    Web3Wrapper.prototype.signTypedDataAsync = function (address, typedData) {\n        return __awaiter(this, void 0, void 0, function () {\n            var signData;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isETHAddressHex('address', address);\n                        assert_1.assert.doesConformToSchema('typedData', typedData, json_schemas_1.schemas.eip712TypedDataSchema);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: 'eth_signTypedData',\n                                params: [address, typedData],\n                            })];\n                    case 1:\n                        signData = _a.sent();\n                        return [2 /*return*/, signData];\n                }\n            });\n        });\n    };\n    /**\n     * Fetches the latest block number\n     * @returns Block number\n     */\n    Web3Wrapper.prototype.getBlockNumberAsync = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var blockNumberHex, blockNumber;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.sendRawPayloadAsync({\n                            method: 'eth_blockNumber',\n                            params: [],\n                        })];\n                    case 1:\n                        blockNumberHex = _a.sent();\n                        blockNumber = utils_2.utils.convertHexToNumberOrNull(blockNumberHex);\n                        return [2 /*return*/, blockNumber];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch a specific Ethereum block without transaction data\n     * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n     * @returns The requested block without transaction data, or undefined if block was not found\n     * (e.g the node isn't fully synced, there was a block re-org and the requested block was uncles, etc...)\n     */\n    Web3Wrapper.prototype.getBlockIfExistsAsync = function (blockParam) {\n        return __awaiter(this, void 0, void 0, function () {\n            var encodedBlockParam, method, shouldIncludeTransactionData, blockWithoutTransactionDataWithHexValuesOrNull, blockWithoutTransactionDataIfExists;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        Web3Wrapper._assertBlockParamOrString(blockParam);\n                        encodedBlockParam = marshaller_1.marshaller.marshalBlockParam(blockParam);\n                        method = utils_2.utils.isHexStrict(blockParam) ? 'eth_getBlockByHash' : 'eth_getBlockByNumber';\n                        shouldIncludeTransactionData = false;\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: method,\n                                params: [encodedBlockParam, shouldIncludeTransactionData],\n                            })];\n                    case 1:\n                        blockWithoutTransactionDataWithHexValuesOrNull = _a.sent();\n                        if (blockWithoutTransactionDataWithHexValuesOrNull !== null) {\n                            blockWithoutTransactionDataIfExists = marshaller_1.marshaller.unmarshalIntoBlockWithoutTransactionData(blockWithoutTransactionDataWithHexValuesOrNull);\n                        }\n                        return [2 /*return*/, blockWithoutTransactionDataIfExists];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch a specific Ethereum block with transaction data\n     * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n     * @returns The requested block with transaction data\n     */\n    Web3Wrapper.prototype.getBlockWithTransactionDataAsync = function (blockParam) {\n        return __awaiter(this, void 0, void 0, function () {\n            var encodedBlockParam, method, shouldIncludeTransactionData, blockWithTransactionDataWithHexValues, blockWithoutTransactionData;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        Web3Wrapper._assertBlockParamOrString(blockParam);\n                        encodedBlockParam = blockParam;\n                        if (_.isNumber(blockParam)) {\n                            encodedBlockParam = utils_2.utils.numberToHex(blockParam);\n                        }\n                        method = utils_2.utils.isHexStrict(blockParam) ? 'eth_getBlockByHash' : 'eth_getBlockByNumber';\n                        shouldIncludeTransactionData = true;\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: method,\n                                params: [encodedBlockParam, shouldIncludeTransactionData],\n                            })];\n                    case 1:\n                        blockWithTransactionDataWithHexValues = _a.sent();\n                        blockWithoutTransactionData = marshaller_1.marshaller.unmarshalIntoBlockWithTransactionData(blockWithTransactionDataWithHexValues);\n                        return [2 /*return*/, blockWithoutTransactionData];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch a block's timestamp\n     * @param blockParam The block you wish to fetch (blockHash, blockNumber or blockLiteral)\n     * @returns The block's timestamp\n     */\n    Web3Wrapper.prototype.getBlockTimestampAsync = function (blockParam) {\n        return __awaiter(this, void 0, void 0, function () {\n            var blockIfExists;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        Web3Wrapper._assertBlockParamOrString(blockParam);\n                        return [4 /*yield*/, this.getBlockIfExistsAsync(blockParam)];\n                    case 1:\n                        blockIfExists = _a.sent();\n                        if (blockIfExists === undefined) {\n                            throw new Error(\"Failed to fetch block with blockParam: \" + JSON.stringify(blockParam));\n                        }\n                        return [2 /*return*/, blockIfExists.timestamp];\n                }\n            });\n        });\n    };\n    /**\n     * Retrieve the user addresses available through the backing provider\n     * @returns Available user addresses\n     */\n    Web3Wrapper.prototype.getAvailableAddressesAsync = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var addresses, normalizedAddresses;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.sendRawPayloadAsync({\n                            method: 'eth_accounts',\n                            params: [],\n                        })];\n                    case 1:\n                        addresses = _a.sent();\n                        normalizedAddresses = _.map(addresses, function (address) { return address.toLowerCase(); });\n                        return [2 /*return*/, normalizedAddresses];\n                }\n            });\n        });\n    };\n    /**\n     * Take a snapshot of the blockchain state on a TestRPC/Ganache local node\n     * @returns The snapshot id. This can be used to revert to this snapshot\n     */\n    Web3Wrapper.prototype.takeSnapshotAsync = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var snapshotId, _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = Number;\n                        return [4 /*yield*/, this.sendRawPayloadAsync({ method: 'evm_snapshot', params: [] })];\n                    case 1:\n                        snapshotId = _a.apply(void 0, [_b.sent()]);\n                        return [2 /*return*/, snapshotId];\n                }\n            });\n        });\n    };\n    /**\n     * Revert the blockchain state to a previous snapshot state on TestRPC/Ganache local node\n     * @param snapshotId snapshot id to revert to\n     * @returns Whether the revert was successful\n     */\n    Web3Wrapper.prototype.revertSnapshotAsync = function (snapshotId) {\n        return __awaiter(this, void 0, void 0, function () {\n            var didRevert;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isNumber('snapshotId', snapshotId);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({ method: 'evm_revert', params: [snapshotId] })];\n                    case 1:\n                        didRevert = _a.sent();\n                        return [2 /*return*/, didRevert];\n                }\n            });\n        });\n    };\n    /**\n     * Mine a block on a TestRPC/Ganache local node\n     */\n    Web3Wrapper.prototype.mineBlockAsync = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.sendRawPayloadAsync({ method: 'evm_mine', params: [] })];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Increase the next blocks timestamp on TestRPC/Ganache or Geth local node.\n     * Will throw if provider is neither TestRPC/Ganache or Geth.\n     * @param timeDelta Amount of time to add in seconds\n     */\n    Web3Wrapper.prototype.increaseTimeAsync = function (timeDelta) {\n        return __awaiter(this, void 0, void 0, function () {\n            var version;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isNumber('timeDelta', timeDelta);\n                        return [4 /*yield*/, this.getNodeVersionAsync()];\n                    case 1:\n                        version = _a.sent();\n                        if (_.includes(version, uniqueVersionIds.geth)) {\n                            return [2 /*return*/, this.sendRawPayloadAsync({ method: 'debug_increaseTime', params: [timeDelta] })];\n                        }\n                        else if (_.includes(version, uniqueVersionIds.ganache)) {\n                            return [2 /*return*/, this.sendRawPayloadAsync({ method: 'evm_increaseTime', params: [timeDelta] })];\n                        }\n                        else {\n                            throw new Error(\"Unknown client version: \" + version);\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Retrieve smart contract logs for a given filter\n     * @param filter Parameters by which to filter which logs to retrieve\n     * @returns The corresponding log entries\n     */\n    Web3Wrapper.prototype.getLogsAsync = function (filter) {\n        return __awaiter(this, void 0, void 0, function () {\n            var fromBlock, toBlock, serializedFilter, payload, rawLogs, formattedLogs;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (filter.blockHash !== undefined && (filter.fromBlock !== undefined || filter.toBlock !== undefined)) {\n                            throw new Error(\"Cannot specify 'blockHash' as well as 'fromBlock'/'toBlock' in the filter supplied to 'getLogsAsync'\");\n                        }\n                        fromBlock = filter.fromBlock;\n                        if (_.isNumber(fromBlock)) {\n                            fromBlock = utils_2.utils.numberToHex(fromBlock);\n                        }\n                        toBlock = filter.toBlock;\n                        if (_.isNumber(toBlock)) {\n                            toBlock = utils_2.utils.numberToHex(toBlock);\n                        }\n                        serializedFilter = __assign({}, filter, { fromBlock: fromBlock,\n                            toBlock: toBlock });\n                        payload = {\n                            method: 'eth_getLogs',\n                            params: [serializedFilter],\n                        };\n                        return [4 /*yield*/, this.sendRawPayloadAsync(payload)];\n                    case 1:\n                        rawLogs = _a.sent();\n                        formattedLogs = _.map(rawLogs, marshaller_1.marshaller.unmarshalLog.bind(marshaller_1.marshaller));\n                        return [2 /*return*/, formattedLogs];\n                }\n            });\n        });\n    };\n    /**\n     * Calculate the estimated gas cost for a given transaction\n     * @param txData Transaction data\n     * @returns Estimated gas cost\n     */\n    Web3Wrapper.prototype.estimateGasAsync = function (txData) {\n        return __awaiter(this, void 0, void 0, function () {\n            var txDataHex, gasHex, gas;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.doesConformToSchema('txData', txData, json_schemas_1.schemas.txDataSchema, [\n                            json_schemas_1.schemas.addressSchema,\n                            json_schemas_1.schemas.numberSchema,\n                            json_schemas_1.schemas.jsNumber,\n                        ]);\n                        txDataHex = marshaller_1.marshaller.marshalTxData(txData);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({ method: 'eth_estimateGas', params: [txDataHex] })];\n                    case 1:\n                        gasHex = _a.sent();\n                        gas = utils_2.utils.convertHexToNumber(gasHex);\n                        return [2 /*return*/, gas];\n                }\n            });\n        });\n    };\n    /**\n     * Call a smart contract method at a given block height\n     * @param callData Call data\n     * @param defaultBlock Block height at which to make the call. Defaults to `latest`\n     * @returns The raw call result\n     */\n    Web3Wrapper.prototype.callAsync = function (callData, defaultBlock) {\n        return __awaiter(this, void 0, void 0, function () {\n            var marshalledDefaultBlock, callDataHex, rawCallResult;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.doesConformToSchema('callData', callData, json_schemas_1.schemas.callDataSchema, [\n                            json_schemas_1.schemas.addressSchema,\n                            json_schemas_1.schemas.numberSchema,\n                            json_schemas_1.schemas.jsNumber,\n                        ]);\n                        if (defaultBlock !== undefined) {\n                            Web3Wrapper._assertBlockParam(defaultBlock);\n                        }\n                        marshalledDefaultBlock = marshaller_1.marshaller.marshalBlockParam(defaultBlock);\n                        callDataHex = marshaller_1.marshaller.marshalCallData(callData);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({\n                                method: 'eth_call',\n                                params: [callDataHex, marshalledDefaultBlock],\n                            })];\n                    case 1:\n                        rawCallResult = _a.sent();\n                        return [2 /*return*/, rawCallResult];\n                }\n            });\n        });\n    };\n    /**\n     * Send a transaction\n     * @param txData Transaction data\n     * @returns Transaction hash\n     */\n    Web3Wrapper.prototype.sendTransactionAsync = function (txData) {\n        return __awaiter(this, void 0, void 0, function () {\n            var txDataHex, txHash;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.doesConformToSchema('txData', txData, json_schemas_1.schemas.txDataSchema, [\n                            json_schemas_1.schemas.addressSchema,\n                            json_schemas_1.schemas.numberSchema,\n                            json_schemas_1.schemas.jsNumber,\n                        ]);\n                        txDataHex = marshaller_1.marshaller.marshalTxData(txData);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({ method: 'eth_sendTransaction', params: [txDataHex] })];\n                    case 1:\n                        txHash = _a.sent();\n                        return [2 /*return*/, txHash];\n                }\n            });\n        });\n    };\n    /**\n     * Waits for a transaction to be mined and returns the transaction receipt.\n     * Note that just because a transaction was mined does not mean it was\n     * successful. You need to check the status code of the transaction receipt\n     * to find out if it was successful, or use the helper method\n     * awaitTransactionSuccessAsync.\n     * @param   txHash            Transaction hash\n     * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.\n     * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.\n     * @return  Transaction receipt with decoded log args.\n     */\n    Web3Wrapper.prototype.awaitTransactionMinedAsync = function (txHash, pollingIntervalMs, timeoutMs) {\n        if (pollingIntervalMs === void 0) { pollingIntervalMs = 1000; }\n        return __awaiter(this, void 0, void 0, function () {\n            var transactionReceipt, logsWithDecodedArgs, transactionReceiptWithDecodedLogArgs, wasTimeoutExceeded, txReceiptPromise, txReceipt;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isHexString('txHash', txHash);\n                        assert_1.assert.isNumber('pollingIntervalMs', pollingIntervalMs);\n                        if (timeoutMs !== undefined) {\n                            assert_1.assert.isNumber('timeoutMs', timeoutMs);\n                        }\n                        return [4 /*yield*/, this.getTransactionReceiptIfExistsAsync(txHash)];\n                    case 1:\n                        transactionReceipt = _a.sent();\n                        if (transactionReceipt !== undefined) {\n                            logsWithDecodedArgs = _.map(transactionReceipt.logs, this.abiDecoder.tryToDecodeLogOrNoop.bind(this.abiDecoder));\n                            transactionReceiptWithDecodedLogArgs = __assign({}, transactionReceipt, { logs: logsWithDecodedArgs });\n                            return [2 /*return*/, transactionReceiptWithDecodedLogArgs];\n                        }\n                        wasTimeoutExceeded = false;\n                        if (timeoutMs) {\n                            setTimeout(function () { return (wasTimeoutExceeded = true); }, timeoutMs);\n                        }\n                        txReceiptPromise = new Promise(function (resolve, reject) {\n                            var intervalId = utils_1.intervalUtils.setAsyncExcludingInterval(function () { return __awaiter(_this, void 0, void 0, function () {\n                                var logsWithDecodedArgs, transactionReceiptWithDecodedLogArgs;\n                                return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                        case 0:\n                                            if (wasTimeoutExceeded) {\n                                                utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                                                return [2 /*return*/, reject(types_1.Web3WrapperErrors.TransactionMiningTimeout)];\n                                            }\n                                            return [4 /*yield*/, this.getTransactionReceiptIfExistsAsync(txHash)];\n                                        case 1:\n                                            transactionReceipt = _a.sent();\n                                            if (transactionReceipt !== undefined) {\n                                                utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                                                logsWithDecodedArgs = _.map(transactionReceipt.logs, this.abiDecoder.tryToDecodeLogOrNoop.bind(this.abiDecoder));\n                                                transactionReceiptWithDecodedLogArgs = __assign({}, transactionReceipt, { logs: logsWithDecodedArgs });\n                                                resolve(transactionReceiptWithDecodedLogArgs);\n                                            }\n                                            return [2 /*return*/];\n                                    }\n                                });\n                            }); }, pollingIntervalMs, function (err) {\n                                utils_1.intervalUtils.clearAsyncExcludingInterval(intervalId);\n                                reject(err);\n                            });\n                        });\n                        return [4 /*yield*/, txReceiptPromise];\n                    case 2:\n                        txReceipt = _a.sent();\n                        return [2 /*return*/, txReceipt];\n                }\n            });\n        });\n    };\n    /**\n     * Waits for a transaction to be mined and returns the transaction receipt.\n     * Unlike awaitTransactionMinedAsync, it will throw if the receipt has a\n     * status that is not equal to 1. A status of 0 or null indicates that the\n     * transaction was mined, but failed. See:\n     * https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethgettransactionreceipt\n     * @param   txHash            Transaction hash\n     * @param   pollingIntervalMs How often (in ms) should we check if the transaction is mined.\n     * @param   timeoutMs         How long (in ms) to poll for transaction mined until aborting.\n     * @return  Transaction receipt with decoded log args.\n     */\n    Web3Wrapper.prototype.awaitTransactionSuccessAsync = function (txHash, pollingIntervalMs, timeoutMs) {\n        if (pollingIntervalMs === void 0) { pollingIntervalMs = 1000; }\n        return __awaiter(this, void 0, void 0, function () {\n            var receipt;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.awaitTransactionMinedAsync(txHash, pollingIntervalMs, timeoutMs)];\n                    case 1:\n                        receipt = _a.sent();\n                        if (receipt.status !== 1) {\n                            throw new Error(\"Transaction failed: \" + txHash);\n                        }\n                        return [2 /*return*/, receipt];\n                }\n            });\n        });\n    };\n    /**\n     * Calls the 'debug_setHead' JSON RPC method, which sets the current head of\n     * the local chain by block number. Note, this is a destructive action and\n     * may severely damage your chain. Use with extreme caution. As of now, this\n     * is only supported by Geth. It sill throw if the 'debug_setHead' method is\n     * not supported.\n     * @param  blockNumber The block number to reset to.\n     */\n    Web3Wrapper.prototype.setHeadAsync = function (blockNumber) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        assert_1.assert.isNumber('blockNumber', blockNumber);\n                        return [4 /*yield*/, this.sendRawPayloadAsync({ method: 'debug_setHead', params: [utils_2.utils.numberToHex(blockNumber)] })];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Sends a raw Ethereum JSON RPC payload and returns the response's `result` key\n     * @param payload A partial JSON RPC payload. No need to include version, id, params (if none needed)\n     * @return The contents nested under the result key of the response body\n     */\n    Web3Wrapper.prototype.sendRawPayloadAsync = function (payload) {\n        return __awaiter(this, void 0, void 0, function () {\n            var sendAsync, payloadWithDefaults, response, result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        sendAsync = this._provider.sendAsync.bind(this._provider);\n                        payloadWithDefaults = __assign({ id: this._jsonRpcRequestId++, params: [], jsonrpc: '2.0' }, payload);\n                        return [4 /*yield*/, utils_1.promisify(sendAsync)(payloadWithDefaults)];\n                    case 1:\n                        response = _a.sent();\n                        if (response.error) {\n                            throw new Error(response.error.message);\n                        }\n                        result = response.result;\n                        return [2 /*return*/, result];\n                }\n            });\n        });\n    };\n    /**\n     * Returns either NodeType.Geth or NodeType.Ganache depending on the type of\n     * the backing Ethereum node. Throws for any other type of node.\n     */\n    Web3Wrapper.prototype.getNodeTypeAsync = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var version;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getNodeVersionAsync()];\n                    case 1:\n                        version = _a.sent();\n                        if (_.includes(version, uniqueVersionIds.geth)) {\n                            return [2 /*return*/, types_1.NodeType.Geth];\n                        }\n                        else if (_.includes(version, uniqueVersionIds.ganache)) {\n                            return [2 /*return*/, types_1.NodeType.Ganache];\n                        }\n                        else {\n                            throw new Error(\"Unknown client version: \" + version);\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return Web3Wrapper;\n}()); // tslint:disable-line:max-file-line-count\nexports.Web3Wrapper = Web3Wrapper;\n//# sourceMappingURL=web3_wrapper.js.map"]},"metadata":{},"sourceType":"script"}