{"ast":null,"code":"import { AbstractConnector } from '@web3-react/abstract-connector';\nimport invariant from 'tiny-invariant';\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nvar URI_AVAILABLE = 'URI_AVAILABLE';\n\nvar UserRejectedRequestError =\n/*#__PURE__*/\nfunction (_Error) {\n  _inheritsLoose(UserRejectedRequestError, _Error);\n\n  function UserRejectedRequestError() {\n    var _this;\n\n    _this = _Error.call(this) || this;\n    _this.name = _this.constructor.name;\n    _this.message = 'The user rejected the request.';\n    return _this;\n  }\n\n  return UserRejectedRequestError;\n}(\n/*#__PURE__*/\n_wrapNativeSuper(Error));\n\nvar WalletConnectConnector =\n/*#__PURE__*/\nfunction (_AbstractConnector) {\n  _inheritsLoose(WalletConnectConnector, _AbstractConnector);\n\n  function WalletConnectConnector(_ref) {\n    var _this2;\n\n    var rpc = _ref.rpc,\n        bridge = _ref.bridge,\n        qrcode = _ref.qrcode,\n        pollingInterval = _ref.pollingInterval;\n    !(Object.keys(rpc).length === 1) ? process.env.NODE_ENV !== \"production\" ? invariant(false, '@walletconnect/web3-provider is broken with >1 chainId, please use 1') : invariant(false) : void 0;\n    _this2 = _AbstractConnector.call(this, {\n      supportedChainIds: Object.keys(rpc).map(function (k) {\n        return Number(k);\n      })\n    }) || this;\n    _this2.rpc = rpc;\n    _this2.bridge = bridge;\n    _this2.qrcode = qrcode;\n    _this2.pollingInterval = pollingInterval;\n    _this2.handleChainChanged = _this2.handleChainChanged.bind(_assertThisInitialized(_this2));\n    _this2.handleAccountsChanged = _this2.handleAccountsChanged.bind(_assertThisInitialized(_this2));\n    _this2.handleDisconnect = _this2.handleDisconnect.bind(_assertThisInitialized(_this2));\n    return _this2;\n  }\n\n  var _proto = WalletConnectConnector.prototype;\n\n  _proto.handleChainChanged = function handleChainChanged(chainId) {\n    if (process.env.NODE_ENV !== \"production\") {\n      console.log(\"Handling 'chainChanged' event with payload\", chainId);\n    }\n\n    this.emitUpdate({\n      chainId: chainId\n    });\n  };\n\n  _proto.handleAccountsChanged = function handleAccountsChanged(accounts) {\n    if (process.env.NODE_ENV !== \"production\") {\n      console.log(\"Handling 'accountsChanged' event with payload\", accounts);\n    }\n\n    this.emitUpdate({\n      account: accounts[0]\n    });\n  };\n\n  _proto.handleDisconnect = function handleDisconnect() {\n    if (process.env.NODE_ENV !== \"production\") {\n      console.log(\"Handling 'disconnect' event\");\n    }\n\n    this.emitDeactivate(); // we have to do this because of a @walletconnect/web3-provider bug\n\n    if (this.walletConnectProvider) {\n      this.walletConnectProvider.stop();\n      this.walletConnectProvider.removeListener('chainChanged', this.handleChainChanged);\n      this.walletConnectProvider.removeListener('accountsChanged', this.handleAccountsChanged);\n      this.walletConnectProvider = undefined;\n    }\n\n    this.emitDeactivate();\n  };\n\n  _proto.activate = function activate() {\n    try {\n      var _temp5 = function _temp5() {\n        function _temp2() {\n          return Promise.resolve(_this4.walletConnectProvider.enable()[\"catch\"](function (error) {\n            // TODO ideally this would be a better check\n            if (error.message === 'User closed WalletConnect modal') {\n              throw new UserRejectedRequestError();\n            }\n\n            throw error;\n          }).then(function (accounts) {\n            return accounts[0];\n          })).then(function (account) {\n            return {\n              provider: _this4.walletConnectProvider,\n              account: account\n            };\n          });\n        }\n\n        _this4.walletConnectProvider.on('chainChanged', _this4.handleChainChanged);\n\n        _this4.walletConnectProvider.on('accountsChanged', _this4.handleAccountsChanged); // ensure that the uri is going to be available, and emit an event if there's a new uri\n\n\n        var _temp = function () {\n          if (!_this4.walletConnectProvider.wc.connected) {\n            return Promise.resolve(_this4.walletConnectProvider.wc.createSession({\n              chainId: _this4.walletConnectProvider.chainId\n            })).then(function () {\n              _this4.emit(URI_AVAILABLE, _this4.walletConnectProvider.wc.uri);\n            });\n          }\n        }();\n\n        return _temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp);\n      };\n\n      var _this4 = this;\n\n      var _temp6 = function () {\n        if (!_this4.walletConnectProvider) {\n          return Promise.resolve(import('@walletconnect/web3-provider')).then(function (_ref2) {\n            var WalletConnectProvider = _ref2[\"default\"];\n            _this4.walletConnectProvider = new WalletConnectProvider({\n              bridge: _this4.bridge,\n              rpc: _this4.rpc,\n              qrcode: _this4.qrcode,\n              pollingInterval: _this4.pollingInterval\n            }); // only doing this here because this.walletConnectProvider.wc doesn't have a removeListener function...\n\n            _this4.walletConnectProvider.wc.on('disconnect', _this4.handleDisconnect);\n          });\n        }\n      }();\n\n      return Promise.resolve(_temp6 && _temp6.then ? _temp6.then(_temp5) : _temp5(_temp6));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.getProvider = function getProvider() {\n    try {\n      var _this6 = this;\n\n      return Promise.resolve(_this6.walletConnectProvider);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.getChainId = function getChainId() {\n    try {\n      var _this8 = this;\n\n      return Promise.resolve(_this8.walletConnectProvider.send('eth_chainId'));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.getAccount = function getAccount() {\n    try {\n      var _this10 = this;\n\n      return Promise.resolve(_this10.walletConnectProvider.send('eth_accounts').then(function (accounts) {\n        return accounts[0];\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.deactivate = function deactivate() {\n    if (this.walletConnectProvider) {\n      this.walletConnectProvider.stop();\n      this.walletConnectProvider.removeListener('chainChanged', this.handleChainChanged);\n      this.walletConnectProvider.removeListener('accountsChanged', this.handleAccountsChanged);\n    }\n  };\n\n  _proto.close = function close() {\n    try {\n      var _this12 = this;\n\n      _this12.walletConnectProvider.wc.killSession();\n\n      return Promise.resolve();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  return WalletConnectConnector;\n}(AbstractConnector);\n\nexport { URI_AVAILABLE, UserRejectedRequestError, WalletConnectConnector };","map":{"version":3,"sources":["../src/index.ts"],"names":["URI_AVAILABLE","UserRejectedRequestError","WalletConnectConnector","rpc","bridge","qrcode","pollingInterval","Object","supportedChainIds","Number","handleChainChanged","console","chainId","handleAccountsChanged","account","accounts","handleDisconnect","walletConnectProvider","WalletConnectProvider","connected","error","provider","deactivate"],"mappings":"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","sourcesContent":["import { ConnectorUpdate } from '@web3-react/types'\nimport { AbstractConnector } from '@web3-react/abstract-connector'\nimport invariant from 'tiny-invariant'\n\nexport const URI_AVAILABLE = 'URI_AVAILABLE'\n\nexport class UserRejectedRequestError extends Error {\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    this.message = 'The user rejected the request.'\n  }\n}\n\ninterface WalletConnectConnectorArguments {\n  rpc: { [chainId: number]: string }\n  bridge?: string\n  qrcode?: boolean\n  pollingInterval?: number\n}\n\nexport class WalletConnectConnector extends AbstractConnector {\n  private readonly rpc: { [chainId: number]: string | undefined }\n  private readonly bridge?: string\n  private readonly qrcode?: boolean\n  private readonly pollingInterval?: number\n\n  public walletConnectProvider: any\n\n  constructor({ rpc, bridge, qrcode, pollingInterval }: WalletConnectConnectorArguments) {\n    invariant(Object.keys(rpc).length === 1, '@walletconnect/web3-provider is broken with >1 chainId, please use 1')\n    super({ supportedChainIds: Object.keys(rpc).map(k => Number(k)) })\n\n    this.rpc = rpc\n    this.bridge = bridge\n    this.qrcode = qrcode\n    this.pollingInterval = pollingInterval\n\n    this.handleChainChanged = this.handleChainChanged.bind(this)\n    this.handleAccountsChanged = this.handleAccountsChanged.bind(this)\n    this.handleDisconnect = this.handleDisconnect.bind(this)\n  }\n\n  private handleChainChanged(chainId: number | string): void {\n    if (__DEV__) {\n      console.log(\"Handling 'chainChanged' event with payload\", chainId)\n    }\n    this.emitUpdate({ chainId })\n  }\n\n  private handleAccountsChanged(accounts: string[]): void {\n    if (__DEV__) {\n      console.log(\"Handling 'accountsChanged' event with payload\", accounts)\n    }\n    this.emitUpdate({ account: accounts[0] })\n  }\n\n  private handleDisconnect(): void {\n    if (__DEV__) {\n      console.log(\"Handling 'disconnect' event\")\n    }\n    this.emitDeactivate()\n    // we have to do this because of a @walletconnect/web3-provider bug\n    if (this.walletConnectProvider) {\n      this.walletConnectProvider.stop()\n      this.walletConnectProvider.removeListener('chainChanged', this.handleChainChanged)\n      this.walletConnectProvider.removeListener('accountsChanged', this.handleAccountsChanged)\n      this.walletConnectProvider = undefined\n    }\n\n    this.emitDeactivate()\n  }\n\n  public async activate(): Promise<ConnectorUpdate> {\n    if (!this.walletConnectProvider) {\n      const { default: WalletConnectProvider } = await import('@walletconnect/web3-provider')\n      this.walletConnectProvider = new WalletConnectProvider({\n        bridge: this.bridge,\n        rpc: this.rpc,\n        qrcode: this.qrcode,\n        pollingInterval: this.pollingInterval\n      })\n      // only doing this here because this.walletConnectProvider.wc doesn't have a removeListener function...\n      this.walletConnectProvider.wc.on('disconnect', this.handleDisconnect)\n    }\n\n    this.walletConnectProvider.on('chainChanged', this.handleChainChanged)\n    this.walletConnectProvider.on('accountsChanged', this.handleAccountsChanged)\n\n    // ensure that the uri is going to be available, and emit an event if there's a new uri\n    if (!this.walletConnectProvider.wc.connected) {\n      await this.walletConnectProvider.wc.createSession({ chainId: this.walletConnectProvider.chainId })\n      this.emit(URI_AVAILABLE, this.walletConnectProvider.wc.uri)\n    }\n\n    const account = await this.walletConnectProvider\n      .enable()\n      .catch((error: Error): void => {\n        // TODO ideally this would be a better check\n        if (error.message === 'User closed WalletConnect modal') {\n          throw new UserRejectedRequestError()\n        }\n\n        throw error\n      })\n      .then((accounts: string[]): string => accounts[0])\n\n    return { provider: this.walletConnectProvider, account }\n  }\n\n  public async getProvider(): Promise<any> {\n    return this.walletConnectProvider\n  }\n\n  public async getChainId(): Promise<number | string> {\n    return this.walletConnectProvider.send('eth_chainId')\n  }\n\n  public async getAccount(): Promise<null | string> {\n    return this.walletConnectProvider.send('eth_accounts').then((accounts: string[]): string => accounts[0])\n  }\n\n  public deactivate() {\n    if (this.walletConnectProvider) {\n      this.walletConnectProvider.stop()\n      this.walletConnectProvider.removeListener('chainChanged', this.handleChainChanged)\n      this.walletConnectProvider.removeListener('accountsChanged', this.handleAccountsChanged)\n    }\n  }\n\n  public async close() {\n    this.walletConnectProvider.wc.killSession()\n  }\n}\n"]},"metadata":{},"sourceType":"module"}