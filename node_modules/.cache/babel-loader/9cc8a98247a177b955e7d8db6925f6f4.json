{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t;\n  return {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  };\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [0, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nexports.__esModule = true;\n/** Class representing a semaphore\n * Semaphores are initialized with a number of permits that get aquired and released\n * over the lifecycle of the Semaphore. These permits limit the number of simultaneous\n * executions of the code that the Semaphore synchronizes. Functions can wait and stop\n * executing until a permit becomes available.\n *\n * Locks that only allow one execution of a critical section are a special case of\n * Semaphores. To construct a lock, initialize a Semaphore with a permit count of 1.\n *\n * This Semaphore class is implemented with the help of promises that get returned\n * by functions that wait for permits to become available. This makes it possible\n * to use async/await to synchronize your code.\n */\n\nvar Semaphore = function () {\n  /**\n   * Creates a semaphore.\n   * @param permits  The number of permits, i.e. things being allowed to run in parallel.\n   * To create a lock that only lets one thing run at a time, set this to 1.\n   * This number can also be negative.\n   */\n  function Semaphore(permits) {\n    this.promiseResolverQueue = [];\n    this.permits = permits;\n  }\n  /**\n   * Returns the number of available permits.\n   * @returns  The number of available permits.\n   */\n\n\n  Semaphore.prototype.getPermits = function () {\n    return this.permits;\n  };\n  /**\n   * Returns a promise used to wait for a permit to become available. This method should be awaited on.\n   * @returns  A promise that gets resolved when execution is allowed to proceed.\n   */\n\n\n  Semaphore.prototype.wait = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        if (this.permits > 0) {\n          this.permits -= 1;\n          return [2\n          /*return*/\n          , Promise.resolve(true)];\n        } // If there is no permit available, we return a promise that resolves once the semaphore gets\n        // signaled enough times that permits is equal to one.\n\n\n        return [2\n        /*return*/\n        , new Promise(function (resolver) {\n          return _this.promiseResolverQueue.push(resolver);\n        })];\n      });\n    });\n  };\n  /**\n   * Alias for {@linkcode Semaphore.wait}.\n   * @returns  A promise that gets resolved when execution is allowed to proceed.\n   */\n\n\n  Semaphore.prototype.acquire = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.wait()];\n      });\n    });\n  };\n  /**\n   * Same as {@linkcode Semaphore.wait} except the promise returned gets resolved with false if no\n   * permit becomes available in time.\n   * @param milliseconds  The time spent waiting before the wait is aborted. This is a lower bound,\n   * don't rely on it being precise.\n   * @returns  A promise that gets resolved with true when execution is allowed to proceed or\n   * false if the time given elapses before a permit becomes available.\n   */\n\n\n  Semaphore.prototype.waitFor = function (milliseconds) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      var resolver, promise;\n      return __generator(this, function (_a) {\n        if (this.permits > 0) {\n          this.permits -= 1;\n          return [2\n          /*return*/\n          , Promise.resolve(true)];\n        }\n\n        resolver = function resolver(b) {\n          return void 0;\n        };\n\n        promise = new Promise(function (r) {\n          resolver = r;\n        }); // The saved resolver gets added to our list of promise resolvers so that it gets a chance\n        // to be resolved as a result of a call to signal().\n\n        this.promiseResolverQueue.push(resolver);\n        setTimeout(function () {\n          // We have to remove the promise resolver from our list. Resolving it twice would not be\n          // an issue but signal() always takes the next resolver from the queue and resolves it which\n          // would swallow a permit if we didn't remove it.\n          var index = _this.promiseResolverQueue.indexOf(resolver);\n\n          if (index !== -1) {\n            _this.promiseResolverQueue.splice(index, 1);\n          } else {} // This is weird... TODO Think about what the best course of action would be at this point.\n          // Probably do nothing.\n          // false because the wait was unsuccessful.\n\n\n          resolver(false);\n        }, milliseconds);\n        return [2\n        /*return*/\n        , promise];\n      });\n    });\n  };\n  /**\n   * Synchronous function that tries to acquire a permit and returns true if successful, false otherwise.\n   * @returns  Whether a permit could be acquired.\n   */\n\n\n  Semaphore.prototype.tryAcquire = function () {\n    if (this.permits > 0) {\n      this.permits -= 1;\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Acquires all permits that are currently available and returns the number of acquired permits.\n   * @returns  Number of acquired permits.\n   */\n\n\n  Semaphore.prototype.drainPermits = function () {\n    if (this.permits > 0) {\n      var permitCount = this.permits;\n      this.permits = 0;\n      return permitCount;\n    }\n\n    return 0;\n  };\n  /**\n   * Increases the number of permits by one. If there are other functions waiting, one of them will\n   * continue to execute in a future iteration of the event loop.\n   */\n\n\n  Semaphore.prototype.signal = function () {\n    this.permits += 1;\n\n    if (this.permits > 1 && this.promiseResolverQueue.length > 0) {\n      throw new Error('this.permits should never be > 0 when there is someone waiting.');\n    } else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {\n      // If there is someone else waiting, immediately consume the permit that was released\n      // at the beginning of this function and let the waiting function resume.\n      this.permits -= 1;\n      var nextResolver = this.promiseResolverQueue.shift();\n\n      if (nextResolver) {\n        nextResolver(true);\n      }\n    }\n  };\n  /**\n   * Alias for {@linkcode Semaphore.signal}.\n   */\n\n\n  Semaphore.prototype.release = function () {\n    this.signal();\n  };\n  /**\n   * Schedules func to be called once a permit becomes available.\n   * Returns a promise that resolves to the return value of func.\n   * @typeparam T  The return type of func.\n   * @param func  The function to be executed.\n   * @return  A promise that gets resolved with the return value of the function.\n   */\n\n\n  Semaphore.prototype.execute = function (func) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.wait()];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2,, 4, 5]);\n\n            return [4\n            /*yield*/\n            , func()];\n\n          case 3:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 4:\n            this.signal();\n            return [7\n            /*endfinally*/\n            ];\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return Semaphore;\n}();\n\nexports[\"default\"] = Semaphore;","map":{"version":3,"sources":["/workspace/uniswap-exchange/node_modules/semaphore-async-await/dist/Semaphore.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","_","label","sent","t","trys","ops","f","y","verb","n","v","op","TypeError","call","pop","length","push","exports","__esModule","Semaphore","permits","promiseResolverQueue","prototype","getPermits","wait","_this","_a","resolver","acquire","waitFor","milliseconds","promise","b","r","setTimeout","index","indexOf","splice","tryAcquire","drainPermits","permitCount","signal","Error","nextResolver","shift","release","execute","func"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t;\n    return { next: verb(0), \"throw\": verb(1), \"return\": verb(2) };\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nexports.__esModule = true;\n/** Class representing a semaphore\n * Semaphores are initialized with a number of permits that get aquired and released\n * over the lifecycle of the Semaphore. These permits limit the number of simultaneous\n * executions of the code that the Semaphore synchronizes. Functions can wait and stop\n * executing until a permit becomes available.\n *\n * Locks that only allow one execution of a critical section are a special case of\n * Semaphores. To construct a lock, initialize a Semaphore with a permit count of 1.\n *\n * This Semaphore class is implemented with the help of promises that get returned\n * by functions that wait for permits to become available. This makes it possible\n * to use async/await to synchronize your code.\n */\nvar Semaphore = (function () {\n    /**\n     * Creates a semaphore.\n     * @param permits  The number of permits, i.e. things being allowed to run in parallel.\n     * To create a lock that only lets one thing run at a time, set this to 1.\n     * This number can also be negative.\n     */\n    function Semaphore(permits) {\n        this.promiseResolverQueue = [];\n        this.permits = permits;\n    }\n    /**\n     * Returns the number of available permits.\n     * @returns  The number of available permits.\n     */\n    Semaphore.prototype.getPermits = function () {\n        return this.permits;\n    };\n    /**\n     * Returns a promise used to wait for a permit to become available. This method should be awaited on.\n     * @returns  A promise that gets resolved when execution is allowed to proceed.\n     */\n    Semaphore.prototype.wait = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                if (this.permits > 0) {\n                    this.permits -= 1;\n                    return [2 /*return*/, Promise.resolve(true)];\n                }\n                // If there is no permit available, we return a promise that resolves once the semaphore gets\n                // signaled enough times that permits is equal to one.\n                return [2 /*return*/, new Promise(function (resolver) { return _this.promiseResolverQueue.push(resolver); })];\n            });\n        });\n    };\n    /**\n     * Alias for {@linkcode Semaphore.wait}.\n     * @returns  A promise that gets resolved when execution is allowed to proceed.\n     */\n    Semaphore.prototype.acquire = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.wait()];\n            });\n        });\n    };\n    /**\n     * Same as {@linkcode Semaphore.wait} except the promise returned gets resolved with false if no\n     * permit becomes available in time.\n     * @param milliseconds  The time spent waiting before the wait is aborted. This is a lower bound,\n     * don't rely on it being precise.\n     * @returns  A promise that gets resolved with true when execution is allowed to proceed or\n     * false if the time given elapses before a permit becomes available.\n     */\n    Semaphore.prototype.waitFor = function (milliseconds) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            var resolver, promise;\n            return __generator(this, function (_a) {\n                if (this.permits > 0) {\n                    this.permits -= 1;\n                    return [2 /*return*/, Promise.resolve(true)];\n                }\n                resolver = function (b) { return void (0); };\n                promise = new Promise(function (r) {\n                    resolver = r;\n                });\n                // The saved resolver gets added to our list of promise resolvers so that it gets a chance\n                // to be resolved as a result of a call to signal().\n                this.promiseResolverQueue.push(resolver);\n                setTimeout(function () {\n                    // We have to remove the promise resolver from our list. Resolving it twice would not be\n                    // an issue but signal() always takes the next resolver from the queue and resolves it which\n                    // would swallow a permit if we didn't remove it.\n                    var index = _this.promiseResolverQueue.indexOf(resolver);\n                    if (index !== -1) {\n                        _this.promiseResolverQueue.splice(index, 1);\n                    }\n                    else {\n                        // This is weird... TODO Think about what the best course of action would be at this point.\n                        // Probably do nothing.\n                    }\n                    // false because the wait was unsuccessful.\n                    resolver(false);\n                }, milliseconds);\n                return [2 /*return*/, promise];\n            });\n        });\n    };\n    /**\n     * Synchronous function that tries to acquire a permit and returns true if successful, false otherwise.\n     * @returns  Whether a permit could be acquired.\n     */\n    Semaphore.prototype.tryAcquire = function () {\n        if (this.permits > 0) {\n            this.permits -= 1;\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Acquires all permits that are currently available and returns the number of acquired permits.\n     * @returns  Number of acquired permits.\n     */\n    Semaphore.prototype.drainPermits = function () {\n        if (this.permits > 0) {\n            var permitCount = this.permits;\n            this.permits = 0;\n            return permitCount;\n        }\n        return 0;\n    };\n    /**\n     * Increases the number of permits by one. If there are other functions waiting, one of them will\n     * continue to execute in a future iteration of the event loop.\n     */\n    Semaphore.prototype.signal = function () {\n        this.permits += 1;\n        if (this.permits > 1 && this.promiseResolverQueue.length > 0) {\n            throw new Error('this.permits should never be > 0 when there is someone waiting.');\n        }\n        else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {\n            // If there is someone else waiting, immediately consume the permit that was released\n            // at the beginning of this function and let the waiting function resume.\n            this.permits -= 1;\n            var nextResolver = this.promiseResolverQueue.shift();\n            if (nextResolver) {\n                nextResolver(true);\n            }\n        }\n    };\n    /**\n     * Alias for {@linkcode Semaphore.signal}.\n     */\n    Semaphore.prototype.release = function () {\n        this.signal();\n    };\n    /**\n     * Schedules func to be called once a permit becomes available.\n     * Returns a promise that resolves to the return value of func.\n     * @typeparam T  The return type of func.\n     * @param func  The function to be executed.\n     * @return  A promise that gets resolved with the return value of the function.\n     */\n    Semaphore.prototype.execute = function (func) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.wait()];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, , 4, 5]);\n                        return [4 /*yield*/, func()];\n                    case 3: return [2 /*return*/, _a.sent()];\n                    case 4:\n                        this.signal();\n                        return [7 /*endfinally*/];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return Semaphore;\n}());\nexports[\"default\"] = Semaphore;\n"]},"metadata":{},"sourceType":"script"}