{"ast":null,"code":"'use strict';\n\nvar urilib = require('url');\n\nvar attribute = require('./attribute');\n\nvar helpers = require('./helpers');\n\nvar scanSchema = require('./scan').scan;\n\nvar ValidatorResult = helpers.ValidatorResult;\nvar SchemaError = helpers.SchemaError;\nvar SchemaContext = helpers.SchemaContext; //var anonymousBase = 'vnd.jsonschema:///';\n\nvar anonymousBase = '/';\n/**\n * Creates a new Validator object\n * @name Validator\n * @constructor\n */\n\nvar Validator = function Validator() {\n  // Allow a validator instance to override global custom formats or to have their\n  // own custom formats.\n  this.customFormats = Object.create(Validator.prototype.customFormats);\n  this.schemas = {};\n  this.unresolvedRefs = []; // Use Object.create to make this extensible without Validator instances stepping on each other's toes.\n\n  this.types = Object.create(types);\n  this.attributes = Object.create(attribute.validators);\n}; // Allow formats to be registered globally.\n\n\nValidator.prototype.customFormats = {}; // Hint at the presence of a property\n\nValidator.prototype.schemas = null;\nValidator.prototype.types = null;\nValidator.prototype.attributes = null;\nValidator.prototype.unresolvedRefs = null;\n/**\n * Adds a schema with a certain urn to the Validator instance.\n * @param schema\n * @param urn\n * @return {Object}\n */\n\nValidator.prototype.addSchema = function addSchema(schema, base) {\n  var self = this;\n\n  if (!schema) {\n    return null;\n  }\n\n  var scan = scanSchema(base || anonymousBase, schema);\n  var ourUri = base || schema.id;\n\n  for (var uri in scan.id) {\n    this.schemas[uri] = scan.id[uri];\n  }\n\n  for (var uri in scan.ref) {\n    this.unresolvedRefs.push(uri);\n  }\n\n  this.unresolvedRefs = this.unresolvedRefs.filter(function (uri) {\n    return typeof self.schemas[uri] === 'undefined';\n  });\n  return this.schemas[ourUri];\n};\n\nValidator.prototype.addSubSchemaArray = function addSubSchemaArray(baseuri, schemas) {\n  if (!(schemas instanceof Array)) return;\n\n  for (var i = 0; i < schemas.length; i++) {\n    this.addSubSchema(baseuri, schemas[i]);\n  }\n};\n\nValidator.prototype.addSubSchemaObject = function addSubSchemaArray(baseuri, schemas) {\n  if (!schemas || typeof schemas != 'object') return;\n\n  for (var p in schemas) {\n    this.addSubSchema(baseuri, schemas[p]);\n  }\n};\n/**\n * Sets all the schemas of the Validator instance.\n * @param schemas\n */\n\n\nValidator.prototype.setSchemas = function setSchemas(schemas) {\n  this.schemas = schemas;\n};\n/**\n * Returns the schema of a certain urn\n * @param urn\n */\n\n\nValidator.prototype.getSchema = function getSchema(urn) {\n  return this.schemas[urn];\n};\n/**\n * Validates instance against the provided schema\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {Array}\n */\n\n\nValidator.prototype.validate = function validate(instance, schema, options, ctx) {\n  if (!options) {\n    options = {};\n  }\n\n  var propertyName = options.propertyName || 'instance'; // This will work so long as the function at uri.resolve() will resolve a relative URI to a relative URI\n\n  var base = urilib.resolve(options.base || anonymousBase, schema.id || '');\n\n  if (!ctx) {\n    ctx = new SchemaContext(schema, options, propertyName, base, Object.create(this.schemas));\n\n    if (!ctx.schemas[base]) {\n      ctx.schemas[base] = schema;\n    }\n\n    var found = scanSchema(base, schema);\n\n    for (var n in found.id) {\n      var sch = found.id[n];\n      ctx.schemas[n] = sch;\n    }\n  }\n\n  if (schema) {\n    var result = this.validateSchema(instance, schema, options, ctx);\n\n    if (!result) {\n      throw new Error('Result undefined');\n    }\n\n    return result;\n  }\n\n  throw new SchemaError('no schema specified', schema);\n};\n/**\n* @param Object schema\n* @return mixed schema uri or false\n*/\n\n\nfunction shouldResolve(schema) {\n  var ref = typeof schema === 'string' ? schema : schema.$ref;\n  if (typeof ref == 'string') return ref;\n  return false;\n}\n/**\n * Validates an instance against the schema (the actual work horse)\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @private\n * @return {ValidatorResult}\n */\n\n\nValidator.prototype.validateSchema = function validateSchema(instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx); // Support for the true/false schemas\n\n  if (typeof schema === 'boolean') {\n    if (schema === true) {\n      // `true` is always valid\n      schema = {};\n    } else if (schema === false) {\n      // `false` is always invalid\n      schema = {\n        type: []\n      };\n    }\n  } else if (!schema) {\n    // This might be a string\n    throw new Error(\"schema is undefined\");\n  }\n\n  if (schema['extends']) {\n    if (schema['extends'] instanceof Array) {\n      var schemaobj = {\n        schema: schema,\n        ctx: ctx\n      };\n      schema['extends'].forEach(this.schemaTraverser.bind(this, schemaobj));\n      schema = schemaobj.schema;\n      schemaobj.schema = null;\n      schemaobj.ctx = null;\n      schemaobj = null;\n    } else {\n      schema = helpers.deepMerge(schema, this.superResolve(schema['extends'], ctx));\n    }\n  } // If passed a string argument, load that schema URI\n\n\n  var switchSchema;\n\n  if (switchSchema = shouldResolve(schema)) {\n    var resolved = this.resolve(schema, switchSchema, ctx);\n    var subctx = new SchemaContext(resolved.subschema, options, ctx.propertyPath, resolved.switchSchema, ctx.schemas);\n    return this.validateSchema(instance, resolved.subschema, options, subctx);\n  }\n\n  var skipAttributes = options && options.skipAttributes || []; // Validate each schema attribute against the instance\n\n  for (var key in schema) {\n    if (!attribute.ignoreProperties[key] && skipAttributes.indexOf(key) < 0) {\n      var validatorErr = null;\n      var validator = this.attributes[key];\n\n      if (validator) {\n        validatorErr = validator.call(this, instance, schema, options, ctx);\n      } else if (options.allowUnknownAttributes === false) {\n        // This represents an error with the schema itself, not an invalid instance\n        throw new SchemaError(\"Unsupported attribute: \" + key, schema);\n      }\n\n      if (validatorErr) {\n        result.importErrors(validatorErr);\n      }\n    }\n  }\n\n  if (typeof options.rewrite == 'function') {\n    var value = options.rewrite.call(this, instance, schema, options, ctx);\n    result.instance = value;\n  }\n\n  return result;\n};\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\n\n\nValidator.prototype.schemaTraverser = function schemaTraverser(schemaobj, s) {\n  schemaobj.schema = helpers.deepMerge(schemaobj.schema, this.superResolve(s, schemaobj.ctx));\n};\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\n\n\nValidator.prototype.superResolve = function superResolve(schema, ctx) {\n  var ref;\n\n  if (ref = shouldResolve(schema)) {\n    return this.resolve(schema, ref, ctx).subschema;\n  }\n\n  return schema;\n};\n/**\n* @private\n* @param Object schema\n* @param Object switchSchema\n* @param SchemaContext ctx\n* @return Object resolved schemas {subschema:String, switchSchema: String}\n* @throws SchemaError\n*/\n\n\nValidator.prototype.resolve = function resolve(schema, switchSchema, ctx) {\n  switchSchema = ctx.resolve(switchSchema); // First see if the schema exists under the provided URI\n\n  if (ctx.schemas[switchSchema]) {\n    return {\n      subschema: ctx.schemas[switchSchema],\n      switchSchema: switchSchema\n    };\n  } // Else try walking the property pointer\n\n\n  var parsed = urilib.parse(switchSchema);\n  var fragment = parsed && parsed.hash;\n  var document = fragment && fragment.length && switchSchema.substr(0, switchSchema.length - fragment.length);\n\n  if (!document || !ctx.schemas[document]) {\n    throw new SchemaError(\"no such schema <\" + switchSchema + \">\", schema);\n  }\n\n  var subschema = helpers.objectGetPath(ctx.schemas[document], fragment.substr(1));\n\n  if (subschema === undefined) {\n    throw new SchemaError(\"no such schema \" + fragment + \" located in <\" + document + \">\", schema);\n  }\n\n  return {\n    subschema: subschema,\n    switchSchema: switchSchema\n  };\n};\n/**\n * Tests whether the instance if of a certain type.\n * @private\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @param type\n * @return {boolean}\n */\n\n\nValidator.prototype.testType = function validateType(instance, schema, options, ctx, type) {\n  if (typeof this.types[type] == 'function') {\n    return this.types[type].call(this, instance);\n  }\n\n  if (type && typeof type == 'object') {\n    var res = this.validateSchema(instance, type, options, ctx);\n    return res === undefined || !(res && res.errors.length);\n  } // Undefined or properties not on the list are acceptable, same as not being defined\n\n\n  return true;\n};\n\nvar types = Validator.prototype.types = {};\n\ntypes.string = function testString(instance) {\n  return typeof instance == 'string';\n};\n\ntypes.number = function testNumber(instance) {\n  // isFinite returns false for NaN, Infinity, and -Infinity\n  return typeof instance == 'number' && isFinite(instance);\n};\n\ntypes.integer = function testInteger(instance) {\n  return typeof instance == 'number' && instance % 1 === 0;\n};\n\ntypes.boolean = function testBoolean(instance) {\n  return typeof instance == 'boolean';\n};\n\ntypes.array = function testArray(instance) {\n  return Array.isArray(instance);\n};\n\ntypes['null'] = function testNull(instance) {\n  return instance === null;\n};\n\ntypes.date = function testDate(instance) {\n  return instance instanceof Date;\n};\n\ntypes.any = function testAny(instance) {\n  return true;\n};\n\ntypes.object = function testObject(instance) {\n  // TODO: fix this - see #15\n  return instance && typeof instance === 'object' && !(instance instanceof Array) && !(instance instanceof Date);\n};\n\nmodule.exports = Validator;","map":{"version":3,"sources":["/workspace/uniswap-exchange/node_modules/jsonschema/lib/validator.js"],"names":["urilib","require","attribute","helpers","scanSchema","scan","ValidatorResult","SchemaError","SchemaContext","anonymousBase","Validator","customFormats","Object","create","prototype","schemas","unresolvedRefs","types","attributes","validators","addSchema","schema","base","self","ourUri","id","uri","ref","push","filter","addSubSchemaArray","baseuri","Array","i","length","addSubSchema","addSubSchemaObject","p","setSchemas","getSchema","urn","validate","instance","options","ctx","propertyName","resolve","found","n","sch","result","validateSchema","Error","shouldResolve","$ref","type","schemaobj","forEach","schemaTraverser","bind","deepMerge","superResolve","switchSchema","resolved","subctx","subschema","propertyPath","skipAttributes","key","ignoreProperties","indexOf","validatorErr","validator","call","allowUnknownAttributes","importErrors","rewrite","value","s","parsed","parse","fragment","hash","document","substr","objectGetPath","undefined","testType","validateType","res","errors","string","testString","number","testNumber","isFinite","integer","testInteger","boolean","testBoolean","array","testArray","isArray","testNull","date","testDate","Date","any","testAny","object","testObject","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,KAAD,CAApB;;AAEA,IAAIC,SAAS,GAAGD,OAAO,CAAC,aAAD,CAAvB;;AACA,IAAIE,OAAO,GAAGF,OAAO,CAAC,WAAD,CAArB;;AACA,IAAIG,UAAU,GAAGH,OAAO,CAAC,QAAD,CAAP,CAAkBI,IAAnC;;AACA,IAAIC,eAAe,GAAGH,OAAO,CAACG,eAA9B;AACA,IAAIC,WAAW,GAAGJ,OAAO,CAACI,WAA1B;AACA,IAAIC,aAAa,GAAGL,OAAO,CAACK,aAA5B,C,CACA;;AACA,IAAIC,aAAa,GAAG,GAApB;AAEA;;;;;;AAKA,IAAIC,SAAS,GAAG,SAASA,SAAT,GAAsB;AACpC;AACA;AACA,OAAKC,aAAL,GAAqBC,MAAM,CAACC,MAAP,CAAcH,SAAS,CAACI,SAAV,CAAoBH,aAAlC,CAArB;AACA,OAAKI,OAAL,GAAe,EAAf;AACA,OAAKC,cAAL,GAAsB,EAAtB,CALoC,CAOpC;;AACA,OAAKC,KAAL,GAAaL,MAAM,CAACC,MAAP,CAAcI,KAAd,CAAb;AACA,OAAKC,UAAL,GAAkBN,MAAM,CAACC,MAAP,CAAcX,SAAS,CAACiB,UAAxB,CAAlB;AACD,CAVD,C,CAYA;;;AACAT,SAAS,CAACI,SAAV,CAAoBH,aAApB,GAAoC,EAApC,C,CAEA;;AACAD,SAAS,CAACI,SAAV,CAAoBC,OAApB,GAA8B,IAA9B;AACAL,SAAS,CAACI,SAAV,CAAoBG,KAApB,GAA4B,IAA5B;AACAP,SAAS,CAACI,SAAV,CAAoBI,UAApB,GAAiC,IAAjC;AACAR,SAAS,CAACI,SAAV,CAAoBE,cAApB,GAAqC,IAArC;AAEA;;;;;;;AAMAN,SAAS,CAACI,SAAV,CAAoBM,SAApB,GAAgC,SAASA,SAAT,CAAoBC,MAApB,EAA4BC,IAA5B,EAAkC;AAChE,MAAIC,IAAI,GAAG,IAAX;;AACA,MAAI,CAACF,MAAL,EAAa;AACX,WAAO,IAAP;AACD;;AACD,MAAIhB,IAAI,GAAGD,UAAU,CAACkB,IAAI,IAAEb,aAAP,EAAsBY,MAAtB,CAArB;AACA,MAAIG,MAAM,GAAGF,IAAI,IAAID,MAAM,CAACI,EAA5B;;AACA,OAAI,IAAIC,GAAR,IAAerB,IAAI,CAACoB,EAApB,EAAuB;AACrB,SAAKV,OAAL,CAAaW,GAAb,IAAoBrB,IAAI,CAACoB,EAAL,CAAQC,GAAR,CAApB;AACD;;AACD,OAAI,IAAIA,GAAR,IAAerB,IAAI,CAACsB,GAApB,EAAwB;AACtB,SAAKX,cAAL,CAAoBY,IAApB,CAAyBF,GAAzB;AACD;;AACD,OAAKV,cAAL,GAAsB,KAAKA,cAAL,CAAoBa,MAApB,CAA2B,UAASH,GAAT,EAAa;AAC5D,WAAO,OAAOH,IAAI,CAACR,OAAL,CAAaW,GAAb,CAAP,KAA2B,WAAlC;AACD,GAFqB,CAAtB;AAGA,SAAO,KAAKX,OAAL,CAAaS,MAAb,CAAP;AACD,CAjBD;;AAmBAd,SAAS,CAACI,SAAV,CAAoBgB,iBAApB,GAAwC,SAASA,iBAAT,CAA2BC,OAA3B,EAAoChB,OAApC,EAA6C;AACnF,MAAG,EAAEA,OAAO,YAAYiB,KAArB,CAAH,EAAgC;;AAChC,OAAI,IAAIC,CAAC,GAAC,CAAV,EAAaA,CAAC,GAAClB,OAAO,CAACmB,MAAvB,EAA+BD,CAAC,EAAhC,EAAmC;AACjC,SAAKE,YAAL,CAAkBJ,OAAlB,EAA2BhB,OAAO,CAACkB,CAAD,CAAlC;AACD;AACF,CALD;;AAOAvB,SAAS,CAACI,SAAV,CAAoBsB,kBAApB,GAAyC,SAASN,iBAAT,CAA2BC,OAA3B,EAAoChB,OAApC,EAA6C;AACpF,MAAG,CAACA,OAAD,IAAY,OAAOA,OAAP,IAAgB,QAA/B,EAAyC;;AACzC,OAAI,IAAIsB,CAAR,IAAatB,OAAb,EAAqB;AACnB,SAAKoB,YAAL,CAAkBJ,OAAlB,EAA2BhB,OAAO,CAACsB,CAAD,CAAlC;AACD;AACF,CALD;AASA;;;;;;AAIA3B,SAAS,CAACI,SAAV,CAAoBwB,UAApB,GAAiC,SAASA,UAAT,CAAqBvB,OAArB,EAA8B;AAC7D,OAAKA,OAAL,GAAeA,OAAf;AACD,CAFD;AAIA;;;;;;AAIAL,SAAS,CAACI,SAAV,CAAoByB,SAApB,GAAgC,SAASA,SAAT,CAAoBC,GAApB,EAAyB;AACvD,SAAO,KAAKzB,OAAL,CAAayB,GAAb,CAAP;AACD,CAFD;AAIA;;;;;;;;;;AAQA9B,SAAS,CAACI,SAAV,CAAoB2B,QAApB,GAA+B,SAASA,QAAT,CAAmBC,QAAnB,EAA6BrB,MAA7B,EAAqCsB,OAArC,EAA8CC,GAA9C,EAAmD;AAChF,MAAI,CAACD,OAAL,EAAc;AACZA,IAAAA,OAAO,GAAG,EAAV;AACD;;AACD,MAAIE,YAAY,GAAGF,OAAO,CAACE,YAAR,IAAwB,UAA3C,CAJgF,CAKhF;;AACA,MAAIvB,IAAI,GAAGtB,MAAM,CAAC8C,OAAP,CAAeH,OAAO,CAACrB,IAAR,IAAcb,aAA7B,EAA4CY,MAAM,CAACI,EAAP,IAAW,EAAvD,CAAX;;AACA,MAAG,CAACmB,GAAJ,EAAQ;AACNA,IAAAA,GAAG,GAAG,IAAIpC,aAAJ,CAAkBa,MAAlB,EAA0BsB,OAA1B,EAAmCE,YAAnC,EAAiDvB,IAAjD,EAAuDV,MAAM,CAACC,MAAP,CAAc,KAAKE,OAAnB,CAAvD,CAAN;;AACA,QAAI,CAAC6B,GAAG,CAAC7B,OAAJ,CAAYO,IAAZ,CAAL,EAAwB;AACtBsB,MAAAA,GAAG,CAAC7B,OAAJ,CAAYO,IAAZ,IAAoBD,MAApB;AACD;;AACD,QAAI0B,KAAK,GAAG3C,UAAU,CAACkB,IAAD,EAAOD,MAAP,CAAtB;;AACA,SAAI,IAAI2B,CAAR,IAAaD,KAAK,CAACtB,EAAnB,EAAsB;AACpB,UAAIwB,GAAG,GAAGF,KAAK,CAACtB,EAAN,CAASuB,CAAT,CAAV;AACAJ,MAAAA,GAAG,CAAC7B,OAAJ,CAAYiC,CAAZ,IAAiBC,GAAjB;AACD;AACF;;AACD,MAAI5B,MAAJ,EAAY;AACV,QAAI6B,MAAM,GAAG,KAAKC,cAAL,CAAoBT,QAApB,EAA8BrB,MAA9B,EAAsCsB,OAAtC,EAA+CC,GAA/C,CAAb;;AACA,QAAI,CAACM,MAAL,EAAa;AACX,YAAM,IAAIE,KAAJ,CAAU,kBAAV,CAAN;AACD;;AACD,WAAOF,MAAP;AACD;;AACD,QAAM,IAAI3C,WAAJ,CAAgB,qBAAhB,EAAuCc,MAAvC,CAAN;AACD,CA1BD;AA4BA;;;;;;AAIA,SAASgC,aAAT,CAAuBhC,MAAvB,EAA+B;AAC7B,MAAIM,GAAG,GAAI,OAAON,MAAP,KAAkB,QAAnB,GAA+BA,MAA/B,GAAwCA,MAAM,CAACiC,IAAzD;AACA,MAAI,OAAO3B,GAAP,IAAY,QAAhB,EAA0B,OAAOA,GAAP;AAC1B,SAAO,KAAP;AACD;AAED;;;;;;;;;;;AASAjB,SAAS,CAACI,SAAV,CAAoBqC,cAApB,GAAqC,SAASA,cAAT,CAAyBT,QAAzB,EAAmCrB,MAAnC,EAA2CsB,OAA3C,EAAoDC,GAApD,EAAyD;AAC5F,MAAIM,MAAM,GAAG,IAAI5C,eAAJ,CAAoBoC,QAApB,EAA8BrB,MAA9B,EAAsCsB,OAAtC,EAA+CC,GAA/C,CAAb,CAD4F,CAG1F;;AACF,MAAG,OAAOvB,MAAP,KAAgB,SAAnB,EAA8B;AAC5B,QAAGA,MAAM,KAAG,IAAZ,EAAiB;AACf;AACAA,MAAAA,MAAM,GAAG,EAAT;AACD,KAHD,MAGM,IAAGA,MAAM,KAAG,KAAZ,EAAkB;AACtB;AACAA,MAAAA,MAAM,GAAG;AAACkC,QAAAA,IAAI,EAAE;AAAP,OAAT;AACD;AACF,GARD,MAQM,IAAG,CAAClC,MAAJ,EAAW;AACf;AACA,UAAM,IAAI+B,KAAJ,CAAU,qBAAV,CAAN;AACD;;AAED,MAAI/B,MAAM,CAAC,SAAD,CAAV,EAAuB;AACrB,QAAIA,MAAM,CAAC,SAAD,CAAN,YAA6BW,KAAjC,EAAwC;AACtC,UAAIwB,SAAS,GAAG;AAACnC,QAAAA,MAAM,EAAEA,MAAT;AAAiBuB,QAAAA,GAAG,EAAEA;AAAtB,OAAhB;AACAvB,MAAAA,MAAM,CAAC,SAAD,CAAN,CAAkBoC,OAAlB,CAA0B,KAAKC,eAAL,CAAqBC,IAArB,CAA0B,IAA1B,EAAgCH,SAAhC,CAA1B;AACAnC,MAAAA,MAAM,GAAGmC,SAAS,CAACnC,MAAnB;AACAmC,MAAAA,SAAS,CAACnC,MAAV,GAAmB,IAAnB;AACAmC,MAAAA,SAAS,CAACZ,GAAV,GAAgB,IAAhB;AACAY,MAAAA,SAAS,GAAG,IAAZ;AACD,KAPD,MAOO;AACLnC,MAAAA,MAAM,GAAGlB,OAAO,CAACyD,SAAR,CAAkBvC,MAAlB,EAA0B,KAAKwC,YAAL,CAAkBxC,MAAM,CAAC,SAAD,CAAxB,EAAqCuB,GAArC,CAA1B,CAAT;AACD;AACF,GA5B2F,CA8B5F;;;AACA,MAAIkB,YAAJ;;AACA,MAAIA,YAAY,GAAGT,aAAa,CAAChC,MAAD,CAAhC,EAA0C;AACxC,QAAI0C,QAAQ,GAAG,KAAKjB,OAAL,CAAazB,MAAb,EAAqByC,YAArB,EAAmClB,GAAnC,CAAf;AACA,QAAIoB,MAAM,GAAG,IAAIxD,aAAJ,CAAkBuD,QAAQ,CAACE,SAA3B,EAAsCtB,OAAtC,EAA+CC,GAAG,CAACsB,YAAnD,EAAiEH,QAAQ,CAACD,YAA1E,EAAwFlB,GAAG,CAAC7B,OAA5F,CAAb;AACA,WAAO,KAAKoC,cAAL,CAAoBT,QAApB,EAA8BqB,QAAQ,CAACE,SAAvC,EAAkDtB,OAAlD,EAA2DqB,MAA3D,CAAP;AACD;;AAED,MAAIG,cAAc,GAAGxB,OAAO,IAAIA,OAAO,CAACwB,cAAnB,IAAqC,EAA1D,CAtC4F,CAuC5F;;AACA,OAAK,IAAIC,GAAT,IAAgB/C,MAAhB,EAAwB;AACtB,QAAI,CAACnB,SAAS,CAACmE,gBAAV,CAA2BD,GAA3B,CAAD,IAAoCD,cAAc,CAACG,OAAf,CAAuBF,GAAvB,IAA8B,CAAtE,EAAyE;AACvE,UAAIG,YAAY,GAAG,IAAnB;AACA,UAAIC,SAAS,GAAG,KAAKtD,UAAL,CAAgBkD,GAAhB,CAAhB;;AACA,UAAII,SAAJ,EAAe;AACbD,QAAAA,YAAY,GAAGC,SAAS,CAACC,IAAV,CAAe,IAAf,EAAqB/B,QAArB,EAA+BrB,MAA/B,EAAuCsB,OAAvC,EAAgDC,GAAhD,CAAf;AACD,OAFD,MAEO,IAAID,OAAO,CAAC+B,sBAAR,KAAmC,KAAvC,EAA8C;AACnD;AACA,cAAM,IAAInE,WAAJ,CAAgB,4BAA4B6D,GAA5C,EAAiD/C,MAAjD,CAAN;AACD;;AACD,UAAIkD,YAAJ,EAAkB;AAChBrB,QAAAA,MAAM,CAACyB,YAAP,CAAoBJ,YAApB;AACD;AACF;AACF;;AAED,MAAI,OAAO5B,OAAO,CAACiC,OAAf,IAA0B,UAA9B,EAA0C;AACxC,QAAIC,KAAK,GAAGlC,OAAO,CAACiC,OAAR,CAAgBH,IAAhB,CAAqB,IAArB,EAA2B/B,QAA3B,EAAqCrB,MAArC,EAA6CsB,OAA7C,EAAsDC,GAAtD,CAAZ;AACAM,IAAAA,MAAM,CAACR,QAAP,GAAkBmC,KAAlB;AACD;;AACD,SAAO3B,MAAP;AACD,CA7DD;AA+DA;;;;;;;;AAMAxC,SAAS,CAACI,SAAV,CAAoB4C,eAApB,GAAsC,SAASA,eAAT,CAA0BF,SAA1B,EAAqCsB,CAArC,EAAwC;AAC5EtB,EAAAA,SAAS,CAACnC,MAAV,GAAmBlB,OAAO,CAACyD,SAAR,CAAkBJ,SAAS,CAACnC,MAA5B,EAAoC,KAAKwC,YAAL,CAAkBiB,CAAlB,EAAqBtB,SAAS,CAACZ,GAA/B,CAApC,CAAnB;AACD,CAFD;AAIA;;;;;;;;AAMAlC,SAAS,CAACI,SAAV,CAAoB+C,YAApB,GAAmC,SAASA,YAAT,CAAuBxC,MAAvB,EAA+BuB,GAA/B,EAAoC;AACrE,MAAIjB,GAAJ;;AACA,MAAGA,GAAG,GAAG0B,aAAa,CAAChC,MAAD,CAAtB,EAAgC;AAC9B,WAAO,KAAKyB,OAAL,CAAazB,MAAb,EAAqBM,GAArB,EAA0BiB,GAA1B,EAA+BqB,SAAtC;AACD;;AACD,SAAO5C,MAAP;AACD,CAND;AAQA;;;;;;;;;;AAQAX,SAAS,CAACI,SAAV,CAAoBgC,OAApB,GAA8B,SAASA,OAAT,CAAkBzB,MAAlB,EAA0ByC,YAA1B,EAAwClB,GAAxC,EAA6C;AACzEkB,EAAAA,YAAY,GAAGlB,GAAG,CAACE,OAAJ,CAAYgB,YAAZ,CAAf,CADyE,CAEzE;;AACA,MAAIlB,GAAG,CAAC7B,OAAJ,CAAY+C,YAAZ,CAAJ,EAA+B;AAC7B,WAAO;AAACG,MAAAA,SAAS,EAAErB,GAAG,CAAC7B,OAAJ,CAAY+C,YAAZ,CAAZ;AAAuCA,MAAAA,YAAY,EAAEA;AAArD,KAAP;AACD,GALwE,CAMzE;;;AACA,MAAIiB,MAAM,GAAG/E,MAAM,CAACgF,KAAP,CAAalB,YAAb,CAAb;AACA,MAAImB,QAAQ,GAAGF,MAAM,IAAIA,MAAM,CAACG,IAAhC;AACA,MAAIC,QAAQ,GAAGF,QAAQ,IAAIA,QAAQ,CAAC/C,MAArB,IAA+B4B,YAAY,CAACsB,MAAb,CAAoB,CAApB,EAAuBtB,YAAY,CAAC5B,MAAb,GAAsB+C,QAAQ,CAAC/C,MAAtD,CAA9C;;AACA,MAAI,CAACiD,QAAD,IAAa,CAACvC,GAAG,CAAC7B,OAAJ,CAAYoE,QAAZ,CAAlB,EAAyC;AACvC,UAAM,IAAI5E,WAAJ,CAAgB,qBAAqBuD,YAArB,GAAoC,GAApD,EAAyDzC,MAAzD,CAAN;AACD;;AACD,MAAI4C,SAAS,GAAG9D,OAAO,CAACkF,aAAR,CAAsBzC,GAAG,CAAC7B,OAAJ,CAAYoE,QAAZ,CAAtB,EAA6CF,QAAQ,CAACG,MAAT,CAAgB,CAAhB,CAA7C,CAAhB;;AACA,MAAGnB,SAAS,KAAGqB,SAAf,EAAyB;AACvB,UAAM,IAAI/E,WAAJ,CAAgB,oBAAoB0E,QAApB,GAA+B,eAA/B,GAAiDE,QAAjD,GAA4D,GAA5E,EAAiF9D,MAAjF,CAAN;AACD;;AACD,SAAO;AAAC4C,IAAAA,SAAS,EAAEA,SAAZ;AAAuBH,IAAAA,YAAY,EAAEA;AAArC,GAAP;AACD,CAlBD;AAoBA;;;;;;;;;;;;AAUApD,SAAS,CAACI,SAAV,CAAoByE,QAApB,GAA+B,SAASC,YAAT,CAAuB9C,QAAvB,EAAiCrB,MAAjC,EAAyCsB,OAAzC,EAAkDC,GAAlD,EAAuDW,IAAvD,EAA6D;AAC1F,MAAI,OAAO,KAAKtC,KAAL,CAAWsC,IAAX,CAAP,IAA2B,UAA/B,EAA2C;AACzC,WAAO,KAAKtC,KAAL,CAAWsC,IAAX,EAAiBkB,IAAjB,CAAsB,IAAtB,EAA4B/B,QAA5B,CAAP;AACD;;AACD,MAAIa,IAAI,IAAI,OAAOA,IAAP,IAAe,QAA3B,EAAqC;AACnC,QAAIkC,GAAG,GAAG,KAAKtC,cAAL,CAAoBT,QAApB,EAA8Ba,IAA9B,EAAoCZ,OAApC,EAA6CC,GAA7C,CAAV;AACA,WAAO6C,GAAG,KAAKH,SAAR,IAAqB,EAAEG,GAAG,IAAIA,GAAG,CAACC,MAAJ,CAAWxD,MAApB,CAA5B;AACD,GAPyF,CAQ1F;;;AACA,SAAO,IAAP;AACD,CAVD;;AAYA,IAAIjB,KAAK,GAAGP,SAAS,CAACI,SAAV,CAAoBG,KAApB,GAA4B,EAAxC;;AACAA,KAAK,CAAC0E,MAAN,GAAe,SAASC,UAAT,CAAqBlD,QAArB,EAA+B;AAC5C,SAAO,OAAOA,QAAP,IAAmB,QAA1B;AACD,CAFD;;AAGAzB,KAAK,CAAC4E,MAAN,GAAe,SAASC,UAAT,CAAqBpD,QAArB,EAA+B;AAC5C;AACA,SAAO,OAAOA,QAAP,IAAmB,QAAnB,IAA+BqD,QAAQ,CAACrD,QAAD,CAA9C;AACD,CAHD;;AAIAzB,KAAK,CAAC+E,OAAN,GAAgB,SAASC,WAAT,CAAsBvD,QAAtB,EAAgC;AAC9C,SAAQ,OAAOA,QAAP,IAAmB,QAApB,IAAiCA,QAAQ,GAAG,CAAX,KAAiB,CAAzD;AACD,CAFD;;AAGAzB,KAAK,CAACiF,OAAN,GAAgB,SAASC,WAAT,CAAsBzD,QAAtB,EAAgC;AAC9C,SAAO,OAAOA,QAAP,IAAmB,SAA1B;AACD,CAFD;;AAGAzB,KAAK,CAACmF,KAAN,GAAc,SAASC,SAAT,CAAoB3D,QAApB,EAA8B;AAC1C,SAAOV,KAAK,CAACsE,OAAN,CAAc5D,QAAd,CAAP;AACD,CAFD;;AAGAzB,KAAK,CAAC,MAAD,CAAL,GAAgB,SAASsF,QAAT,CAAmB7D,QAAnB,EAA6B;AAC3C,SAAOA,QAAQ,KAAK,IAApB;AACD,CAFD;;AAGAzB,KAAK,CAACuF,IAAN,GAAa,SAASC,QAAT,CAAmB/D,QAAnB,EAA6B;AACxC,SAAOA,QAAQ,YAAYgE,IAA3B;AACD,CAFD;;AAGAzF,KAAK,CAAC0F,GAAN,GAAY,SAASC,OAAT,CAAkBlE,QAAlB,EAA4B;AACtC,SAAO,IAAP;AACD,CAFD;;AAGAzB,KAAK,CAAC4F,MAAN,GAAe,SAASC,UAAT,CAAqBpE,QAArB,EAA+B;AAC5C;AACA,SAAOA,QAAQ,IAAK,OAAOA,QAAR,KAAsB,QAAlC,IAA8C,EAAEA,QAAQ,YAAYV,KAAtB,CAA9C,IAA8E,EAAEU,QAAQ,YAAYgE,IAAtB,CAArF;AACD,CAHD;;AAKAK,MAAM,CAACC,OAAP,GAAiBtG,SAAjB","sourcesContent":["'use strict';\n\nvar urilib = require('url');\n\nvar attribute = require('./attribute');\nvar helpers = require('./helpers');\nvar scanSchema = require('./scan').scan;\nvar ValidatorResult = helpers.ValidatorResult;\nvar SchemaError = helpers.SchemaError;\nvar SchemaContext = helpers.SchemaContext;\n//var anonymousBase = 'vnd.jsonschema:///';\nvar anonymousBase = '/';\n\n/**\n * Creates a new Validator object\n * @name Validator\n * @constructor\n */\nvar Validator = function Validator () {\n  // Allow a validator instance to override global custom formats or to have their\n  // own custom formats.\n  this.customFormats = Object.create(Validator.prototype.customFormats);\n  this.schemas = {};\n  this.unresolvedRefs = [];\n\n  // Use Object.create to make this extensible without Validator instances stepping on each other's toes.\n  this.types = Object.create(types);\n  this.attributes = Object.create(attribute.validators);\n};\n\n// Allow formats to be registered globally.\nValidator.prototype.customFormats = {};\n\n// Hint at the presence of a property\nValidator.prototype.schemas = null;\nValidator.prototype.types = null;\nValidator.prototype.attributes = null;\nValidator.prototype.unresolvedRefs = null;\n\n/**\n * Adds a schema with a certain urn to the Validator instance.\n * @param schema\n * @param urn\n * @return {Object}\n */\nValidator.prototype.addSchema = function addSchema (schema, base) {\n  var self = this;\n  if (!schema) {\n    return null;\n  }\n  var scan = scanSchema(base||anonymousBase, schema);\n  var ourUri = base || schema.id;\n  for(var uri in scan.id){\n    this.schemas[uri] = scan.id[uri];\n  }\n  for(var uri in scan.ref){\n    this.unresolvedRefs.push(uri);\n  }\n  this.unresolvedRefs = this.unresolvedRefs.filter(function(uri){\n    return typeof self.schemas[uri]==='undefined';\n  });\n  return this.schemas[ourUri];\n};\n\nValidator.prototype.addSubSchemaArray = function addSubSchemaArray(baseuri, schemas) {\n  if(!(schemas instanceof Array)) return;\n  for(var i=0; i<schemas.length; i++){\n    this.addSubSchema(baseuri, schemas[i]);\n  }\n};\n\nValidator.prototype.addSubSchemaObject = function addSubSchemaArray(baseuri, schemas) {\n  if(!schemas || typeof schemas!='object') return;\n  for(var p in schemas){\n    this.addSubSchema(baseuri, schemas[p]);\n  }\n};\n\n\n\n/**\n * Sets all the schemas of the Validator instance.\n * @param schemas\n */\nValidator.prototype.setSchemas = function setSchemas (schemas) {\n  this.schemas = schemas;\n};\n\n/**\n * Returns the schema of a certain urn\n * @param urn\n */\nValidator.prototype.getSchema = function getSchema (urn) {\n  return this.schemas[urn];\n};\n\n/**\n * Validates instance against the provided schema\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {Array}\n */\nValidator.prototype.validate = function validate (instance, schema, options, ctx) {\n  if (!options) {\n    options = {};\n  }\n  var propertyName = options.propertyName || 'instance';\n  // This will work so long as the function at uri.resolve() will resolve a relative URI to a relative URI\n  var base = urilib.resolve(options.base||anonymousBase, schema.id||'');\n  if(!ctx){\n    ctx = new SchemaContext(schema, options, propertyName, base, Object.create(this.schemas));\n    if (!ctx.schemas[base]) {\n      ctx.schemas[base] = schema;\n    }\n    var found = scanSchema(base, schema);\n    for(var n in found.id){\n      var sch = found.id[n];\n      ctx.schemas[n] = sch;\n    }\n  }\n  if (schema) {\n    var result = this.validateSchema(instance, schema, options, ctx);\n    if (!result) {\n      throw new Error('Result undefined');\n    }\n    return result;\n  }\n  throw new SchemaError('no schema specified', schema);\n};\n\n/**\n* @param Object schema\n* @return mixed schema uri or false\n*/\nfunction shouldResolve(schema) {\n  var ref = (typeof schema === 'string') ? schema : schema.$ref;\n  if (typeof ref=='string') return ref;\n  return false;\n}\n\n/**\n * Validates an instance against the schema (the actual work horse)\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @private\n * @return {ValidatorResult}\n */\nValidator.prototype.validateSchema = function validateSchema (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n    // Support for the true/false schemas\n  if(typeof schema==='boolean') {\n    if(schema===true){\n      // `true` is always valid\n      schema = {};\n    }else if(schema===false){\n      // `false` is always invalid\n      schema = {type: []};\n    }\n  }else if(!schema){\n    // This might be a string\n    throw new Error(\"schema is undefined\");\n  }\n\n  if (schema['extends']) {\n    if (schema['extends'] instanceof Array) {\n      var schemaobj = {schema: schema, ctx: ctx};\n      schema['extends'].forEach(this.schemaTraverser.bind(this, schemaobj));\n      schema = schemaobj.schema;\n      schemaobj.schema = null;\n      schemaobj.ctx = null;\n      schemaobj = null;\n    } else {\n      schema = helpers.deepMerge(schema, this.superResolve(schema['extends'], ctx));\n    }\n  }\n\n  // If passed a string argument, load that schema URI\n  var switchSchema;\n  if (switchSchema = shouldResolve(schema)) {\n    var resolved = this.resolve(schema, switchSchema, ctx);\n    var subctx = new SchemaContext(resolved.subschema, options, ctx.propertyPath, resolved.switchSchema, ctx.schemas);\n    return this.validateSchema(instance, resolved.subschema, options, subctx);\n  }\n\n  var skipAttributes = options && options.skipAttributes || [];\n  // Validate each schema attribute against the instance\n  for (var key in schema) {\n    if (!attribute.ignoreProperties[key] && skipAttributes.indexOf(key) < 0) {\n      var validatorErr = null;\n      var validator = this.attributes[key];\n      if (validator) {\n        validatorErr = validator.call(this, instance, schema, options, ctx);\n      } else if (options.allowUnknownAttributes === false) {\n        // This represents an error with the schema itself, not an invalid instance\n        throw new SchemaError(\"Unsupported attribute: \" + key, schema);\n      }\n      if (validatorErr) {\n        result.importErrors(validatorErr);\n      }\n    }\n  }\n\n  if (typeof options.rewrite == 'function') {\n    var value = options.rewrite.call(this, instance, schema, options, ctx);\n    result.instance = value;\n  }\n  return result;\n};\n\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\nValidator.prototype.schemaTraverser = function schemaTraverser (schemaobj, s) {\n  schemaobj.schema = helpers.deepMerge(schemaobj.schema, this.superResolve(s, schemaobj.ctx));\n}\n\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\nValidator.prototype.superResolve = function superResolve (schema, ctx) {\n  var ref;\n  if(ref = shouldResolve(schema)) {\n    return this.resolve(schema, ref, ctx).subschema;\n  }\n  return schema;\n}\n\n/**\n* @private\n* @param Object schema\n* @param Object switchSchema\n* @param SchemaContext ctx\n* @return Object resolved schemas {subschema:String, switchSchema: String}\n* @throws SchemaError\n*/\nValidator.prototype.resolve = function resolve (schema, switchSchema, ctx) {\n  switchSchema = ctx.resolve(switchSchema);\n  // First see if the schema exists under the provided URI\n  if (ctx.schemas[switchSchema]) {\n    return {subschema: ctx.schemas[switchSchema], switchSchema: switchSchema};\n  }\n  // Else try walking the property pointer\n  var parsed = urilib.parse(switchSchema);\n  var fragment = parsed && parsed.hash;\n  var document = fragment && fragment.length && switchSchema.substr(0, switchSchema.length - fragment.length);\n  if (!document || !ctx.schemas[document]) {\n    throw new SchemaError(\"no such schema <\" + switchSchema + \">\", schema);\n  }\n  var subschema = helpers.objectGetPath(ctx.schemas[document], fragment.substr(1));\n  if(subschema===undefined){\n    throw new SchemaError(\"no such schema \" + fragment + \" located in <\" + document + \">\", schema);\n  }\n  return {subschema: subschema, switchSchema: switchSchema};\n};\n\n/**\n * Tests whether the instance if of a certain type.\n * @private\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @param type\n * @return {boolean}\n */\nValidator.prototype.testType = function validateType (instance, schema, options, ctx, type) {\n  if (typeof this.types[type] == 'function') {\n    return this.types[type].call(this, instance);\n  }\n  if (type && typeof type == 'object') {\n    var res = this.validateSchema(instance, type, options, ctx);\n    return res === undefined || !(res && res.errors.length);\n  }\n  // Undefined or properties not on the list are acceptable, same as not being defined\n  return true;\n};\n\nvar types = Validator.prototype.types = {};\ntypes.string = function testString (instance) {\n  return typeof instance == 'string';\n};\ntypes.number = function testNumber (instance) {\n  // isFinite returns false for NaN, Infinity, and -Infinity\n  return typeof instance == 'number' && isFinite(instance);\n};\ntypes.integer = function testInteger (instance) {\n  return (typeof instance == 'number') && instance % 1 === 0;\n};\ntypes.boolean = function testBoolean (instance) {\n  return typeof instance == 'boolean';\n};\ntypes.array = function testArray (instance) {\n  return Array.isArray(instance);\n};\ntypes['null'] = function testNull (instance) {\n  return instance === null;\n};\ntypes.date = function testDate (instance) {\n  return instance instanceof Date;\n};\ntypes.any = function testAny (instance) {\n  return true;\n};\ntypes.object = function testObject (instance) {\n  // TODO: fix this - see #15\n  return instance && (typeof instance) === 'object' && !(instance instanceof Array) && !(instance instanceof Date);\n};\n\nmodule.exports = Validator;\n"]},"metadata":{},"sourceType":"script"}